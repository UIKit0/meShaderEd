<?xml version="1.0"?>

<node name="Worley" author="Pixar" icon="Worley.png">
	<help>"Worley noise" from "A Cellular Texture Basis Function", SIGGRAPH '96</help>
	<input>
		<property name="frequency" type="float" default="4.0" subtype="slider" range="0.1 100 0.1">
		<help>Controls the size of the cells. Higher frequencies make smaller cells.</help></property>
		<property name="distancemetric" type="float" default="0" detail="uniform" subtype="selector" range="Euclidian:Manhattan">
		<help>The means to measure distances to neighboring cells.  
		      Manhattan distance gives more rectangular shapes and Euclidian distance
		    gives more spherical shapes.</help></property>
		<property name="jitter" type="float" default="0.75" subtype="slider" range="0 1 0.01">
		<help>Controls the distortion of the cells.</help></property>		
		
		<property name="clamp" type="float" default="1" subtype="switch">
		<help>Causes resulting distances to be clamped to the range 0->1</help></property>
		
		<property name="c1" type="float" default="0.8" subtype="slider" range="-2 2 0.01">
		<help>Multiplier for the distances to the first feature.</help></property>	
		
		<property name="c2" type="float" default="-0.2" subtype="slider" range="-2 2 0.01">
		<help>Multiplier for the distances to the second feature.</help></property>		
		
		<property name="Q" type="point"/>	
	</input>
	<output>
		<property name="result" type="float"/>			
	</output>
	<internal>
		<variable name="f1"/>
		<variable name="f2"/>
		<variable name="thiscell"/>
		<variable name="testcell"/>
		<variable name="i"/>
		<variable name="j"/>
		<variable name="k"/>
		<variable name="pp"/>
		<variable name="pos"/>
		<variable name="offset"/>
		<variable name="dist"/>
	</internal>
	<code>
<![CDATA[
/*  Worley noise -- 3-D, 2-feature version.*/
float $(f1), $(f2);
point $(pp) = $(frequency) * $(Q);
point $(thiscell) = point ( floor ( xcomp ( $(pp) ) ) + 0.5, 
                            floor ( ycomp ( $(pp) ) ) + 0.5, 
                            floor ( zcomp ( $(pp) ) ) + 0.5 );
$(f1) = $(f2) = 1000;
uniform float $(i), $(j), $(k);
for ( $(i) = -1;  $(i) <= 1;  $(i) += 1 ) 
{
  for ( $(j) = -1;  $(j) <= 1;  $(j) += 1 ) 
  {
    for ( $(k) = -1;  $(k) <= 1;  $(k) += 1 ) 
    {
      point $(testcell) = $(thiscell) + vector ( $(i), $(j) , $(k) );
      point $(pos) = $(testcell) + $(jitter) * ( vector cellnoise ( $(testcell) ) - 0.5 );
      vector $(offset) = $(pos) - $(pp);
      float $(dist);
      if ( $(distancemetric) == 0 )  /* "Euclidian" */	
        $(dist) = $(offset).$(offset);
      else
      {
        $(dist) = abs ( xcomp ( $(offset) ) ) + abs ( ycomp ( $(offset) ) ) + abs ( zcomp ( $(offset) ) );
      }
      if ( $(dist) < $(f1) ) 
      {
        $(f2) = $(f1);
        $(f1) = $(dist);
      } 
      else if ( $(dist) < $(f2) ) 
      {
        $(f2) = $(dist);
      }
    }
  }
}
if ( $(distancemetric) == 0 )  /* "Euclidian" */  	
{
  $(f1) = sqrt ( $(f1) );
  $(f2) = sqrt ( $(f2) );
}
$(result) = $(f1) * $(c1) + $(f2) * $(c2);
if ( $(clamp) != 0 )
  $(result) = clamp( $(result), 0, 1 );

]]>
	</code>		
</node>
