<!DOCTYPE render_icon>
<nodenet author="meShaderEd" name="render_icon">
 <help>Short NodeNetwork description</help>
 <nodes>
  <node icon="" type="rib" author="mesh" id="1" name="BasicPrimitive" label="BasicPrimitive">
   <help>Basic primitive preview RIB</help>
   <input>
    <property default="" type="rib" value="" name="Globals" label="Render Options"/>
    <property provider="attribute" default="Sphere" range="Sphere:Teapot:Cylinder:Torus:Plane" subtype="selector" type="string" value="Sphere" name="Primitive" label="Primitive"/>
    <property provider="attribute" default="256" type="int" value="128" name="Width" label="Image width"/>
    <property provider="attribute" default="256" type="int" value="128" name="Height" label="Image height"/>
    <property provider="attribute" default="1.250" type="float" value="0.000" name="EnvIntensity" label="EnvLight Intensity"/>
    <property provider="attribute" default="kitchen_LL.hdr.${TEX}" range="All files=*.*:TEX=*.tex:TDL=*.tdl:TIFF=*.tif" subtype="file" type="string" value="kitchen_LL.hdr.${TEX}" name="EnvMap" label="Environment Map"/>
    <property provider="attribute" default="0.000 0.000 1.000" type="color" value="0.000 0.000 1.000" name="Color" label="Color"/>
    <property provider="attribute" default="1.000 1.000 1.000" type="color" value="1.000 1.000 1.000" name="Opacity" label="Opacity"/>
    <property default="null" type="displacement" value="null" name="FG_disp" label="Displace Shader"/>
    <property provider="attribute" default="0.500" type="float" value="0.500" name="DisplaceBound" label="Displacement Bound"/>
    <property default="defaultsurface" type="surface" value="defaultsurface" name="FG_surf" label="Surface Shader"/>
    <property default="liquidchecker" type="surface" value="liquidchecker" name="BG_surf" label="Background Shader"/>
    <property display="hidden" provider="attribute" default="" type="string" value="Rotate 60 1 0 0&#xa; Sphere 1.0 -1.0 1.0 360" name="PrimitiveCode" label="PrimitiveCode"/>
   </input>
   <output>
    <property default="${TempPath}/${NODELABEL}.tif" type="image" value="${TempPath}/${NODELABEL}.tif" name="ImageFile" label="ImageFile"/>
   </output>
   <internal/>
   <include/>
   <param_code><![CDATA[
print ":: Hello from %s XML code !!!" % self.label

if self.getInputParamByName ( 'Primitive' ).value == 'Sphere': 
  self.getInputParamByName ( 'PrimitiveCode' ).value = "Rotate 60 1 0 0\n Sphere 1.0 -1.0 1.0 360"
  
if self.getInputParamByName ( 'Primitive' ).value == 'Teapot': 
  self.getInputParamByName ( 'PrimitiveCode' ).value = """
      Rotate 0 0 1 0
      AttributeBegin
        Scale 0.35 0.35 0.35
        Translate -0.6 -1 0
        Rotate 120 -1 0 0
        Rotate 30 0 0 1
        Geometry \"teapot\"
      AttributeEnd
      """
      
if self.getInputParamByName ( 'Primitive' ).value == 'Cylinder': 
  self.getInputParamByName ( 'PrimitiveCode' ).value = "Rotate 60 1 0 0\n Cylinder 1 -0.5 0.5 360"
  
if self.getInputParamByName ( 'Primitive' ).value == 'Torus': 
  self.getInputParamByName ( 'PrimitiveCode' ).value = """
  Rotate 45 1 0 0
  Torus 0.7 0.4 0.0 360 360
  """

if self.getInputParamByName ( 'Primitive' ).value == 'Plane': 
  self.getInputParamByName ( 'PrimitiveCode' ).value = 'Patch "bilinear" "P" [-1 1 0 1 1 0 -1 -1 0 1 -1 0]'


]]></param_code>
   <code><![CDATA[
  Option "searchpath" "shader" "&:@:.:~:${ShaderSearchPath}:${ProjectSearchPath}:${ProjectSearchShaders}"
  Option "searchpath" "texture" "&:@:.:~:${TextureSearchPath}:${ProjectSearchPath}:${ProjectSearchTextures}"

  $(Globals)

  ### Output image
  Display "$(ImageFile)" "tiff" "rgba"

  Format $(Width) $(Height) 1.0

  Projection "perspective" "fov" 45
  Translate 0 0 3.0

  Attribute "displacementbound" "float sphere" [$(DisplaceBound)]

  WorldBegin

    ReverseOrientation 
	
    TransformBegin
      Rotate -90 1 0 0
      CoordinateSystem "_environment"
    TransformEnd

    LightSource "distantlight" 1 "intensity" 1.0 "from" [-2 2 -3] "to" [0 0 0]
    LightSource "distantlight" 2 "intensity" 0.4 "from" [6 -3 0] "to" [0 0 0]
    LightSource "meEnvLight" 3  "uniform float Intensity" [$(EnvIntensity)] 
                                "uniform string meEnvMap_EnvMap" ["$(EnvMap)"]
                                "uniform string meEnvMap_Space" ["_environment"]

    AttributeBegin 
      
      
      
      Color [$(Color)]
      Opacity [$(Opacity)]

      Displacement "$(FG_disp)"
      Surface "$(FG_surf)" 
      
      $(PrimitiveCode)
      
    AttributeEnd 
      
    AttributeBegin 
      Scale 7 7 7
      Translate 0 0 2
      Surface "$(BG_surf)" 
      
      Patch "bilinear" "P" [-1 1 0 1 1 0 -1 -1 0 1 -1 0]
    AttributeEnd  

  WorldEnd
  ]]></code>
   <offset x="119" y="-291"/>
  </node>
  <node icon="" type="image" author="mesh" id="2" name="imageViewer" label="imageViewer">
   <help>Single image viewer </help>
   <input>
    <property default="" range="All files=*.*:TIFF=*.tif:PNG=*.png:JPEG=*.jpg" subtype="file" type="image" value="" name="image" label="image"/>
   </input>
   <output/>
   <internal/>
   <include/>
   <param_code><![CDATA[
#$(output) = $(input)
#import core.imageNode
#import code.nodeParam

print ":: Hello from %s XML code !!!" % self.label
self.imageName = self.getInputParamValueByName ( 'image' ) 


]]></param_code>
   <offset x="259" y="-260"/>
  </node>
  <node icon="" type="rib_code" author="mesh" id="3" name="RenderGlobals" label="RenderGlobals">
   <help>RenderGlobals options</help>
   <input>
    <property provider="attribute" default="hidden" range="hidden:raytrace:photon:zbuffer:opengl" subtype="selector" type="string" value="hidden" name="Hider" label="Hider"/>
    <property provider="attribute" default="1" subtype="switch" type="int" value="1" name="Jitter" label="Jitter"/>
    <property provider="attribute" default="1.000" type="float" value="0.100" name="ShadingRate" label="Shading rate"/>
    <property provider="attribute" default="4" type="int" value="4" name="Samples" label="Samples"/>
    <property provider="attribute" default="catmull-rom" range="box:triangle:catmull-rom:gaussian:sinc:blackman-harris:mitchell:separable-catmull-rom:lanczos:bessel" subtype="selector" type="string" value="catmull-rom" name="Filter" label="Filter"/>
    <property provider="attribute" default="2.000" type="float" value="2.000" name="FilterWidth" label="Filter width"/>
    <property default="" type="rib" value="" name="Options" label="Options"/>
   </input>
   <output>
    <property default="" type="rib" value="" name="rib" label="rib"/>
   </output>
   <internal/>
   <include/>
   <code><![CDATA[
  ##Option "searchpath" "shader" "&:@:.:~:${ShaderSearchPath}:${ProjectSearchPath}:${ProjectSearchShaders}"
  ##Option "searchpath" "texture" "&:@:.:~:${TextureSearchPath}:${ProjectSearchPath}:${ProjectSearchTextures}"

  Hider "hidden" "int jitter" [1]

  PixelSamples $(Samples) $(Samples)
  PixelFilter "$(Filter)" $(FilterWidth) $(FilterWidth)
  ShadingRate $(ShadingRate)

  $(Options)
  ]]></code>
   <offset x="-96" y="-440"/>
  </node>
  <node icon="" type="surface" author="mesh" id="4" name="surface" label="surf">
   <help>Basic surface shader.</help>
   <input>
    <property default="color(0.000,0.000,0.000)" type="color" value="color(0.000,0.000,0.000)" name="Ci" label="Ci"/>
    <property default="color(1.000,1.000,1.000)" type="color" value="color(1.000,1.000,1.000)" name="Oi" label="Oi"/>
   </input>
   <output>
    <property default="${NODELABEL}" type="surface" value="${NODELABEL}" name="surface" label="surface"/>
   </output>
   <internal/>
   <include/>
   <code><![CDATA[
	  Ci = $(Ci) * $(Oi); 
	  Oi = $(Oi);
	]]></code>
   <offset x="-17" y="-138"/>
  </node>
  <node icon="" type="rsl_code" author="" id="5" name="floatToColor" label="floatToColor">
   <help>Float to color converter.</help>
   <input>
    <property default="1.000" type="float" value="1.000" name="inFloat" label="inFloat"/>
   </input>
   <output>
    <property default="color(0.000,0.000,0.000)" type="color" value="color(0.000,0.000,0.000)" name="outColor" label="outColor"/>
   </output>
   <internal/>
   <include/>
   <code><![CDATA[
	  $(outColor) = color($(inFloat), $(inFloat), $(inFloat));
	  ]]></code>
   <offset x="101" y="242"/>
  </node>
  <node icon="" type="" author="Pixar" id="7" name="SurfaceP" label="SurfaceP">
   <help>Returns the 3D point on the surface of your object.</help>
   <input>
    <property detail="uniform" default="" type="string" value="" name="Space" label="Space">
     <help>The name of a coordinate system for the manifold.
		    In addition to your custom coordinate systems
		    you can use "current", "world", "object", "shader"
		    and "NDC" (screen coordinates).</help>
    </property>
    <property default="1.000" range="0 10 .001" subtype="slider" type="float" value="1.000" name="Frequency" label="Frequency">
     <help>Controls the scale of the manifold.  Note
		    that increasing the frequency of the manifold will result
		    in decreasing the scale of a feature.</help>
    </property>
    <property default="1.000" subtype="switch" type="float" value="1.000" name="IgnorePref" label="IgnorePref">
     <help>If you have attached __Pref geometry and,
		    for debugging purposes, want to ignore it, click
		    here.  Note that it's much more efficient to simply
		    remove the reference geometry if it's not needed.</help>
    </property>
    <property detail="varying" provider="primitive" default="point(-1.000,-1.000,-1.000)" type="point" value="point(-1.000,-1.000,-1.000)" name="__Pref" label="__Pref"/>
   </input>
   <output>
    <property default="point(0.000,0.000,0.000)" type="point" value="point(0.000,0.000,0.000)" name="Q" label="Q"/>
    <property default="vector(0.000,0.000,0.000)" type="vector" value="vector(0.000,0.000,0.000)" name="duQ" label="duQ"/>
    <property default="vector(0.000,0.000,0.000)" type="vector" value="vector(0.000,0.000,0.000)" name="dvQ" label="dvQ"/>
   </output>
   <internal>
    <variable name="sys"/>
   </internal>
   <include/>
   <code><![CDATA[

	uniform string $(sys);
	
	if ( $(Space) == "" )
    $(sys) = "shader";
  else
    $(sys) = $(Space);
      
  if ( xcomp(__Pref) == -1e10 || $(IgnorePref) != 0 )
  {
    $(Q) = $(Frequency) * transform( $(sys), P );
  	$(duQ) = vtransform( $(sys), dPdu * du * $(Frequency) );
  	$(dvQ) = vtransform( $(sys), dPdv * dv * $(Frequency) );
  }
  else 
  {
    $(Q) = $(Frequency) * transform( $(sys), __Pref );
    $(duQ) = vector Du( $(Q) ) * du;
    $(dvQ) = vector Dv( $(Q) ) * dv;
  }
	]]></code>
   <offset x="-776" y="73"/>
  </node>
  <node icon="" type="rsl_code" author="" id="11" name="vectorToColor" label="vectorToColor">
   <help>Vector to color converter.</help>
   <input>
    <property default="vector(0.000,0.000,0.000)" type="vector" value="vector(0.000,0.000,0.000)" name="inVector" label="inVector"/>
   </input>
   <output>
    <property default="color(0.000,0.000,0.000)" type="color" value="color(0.000,0.000,0.000)" name="outColor" label="outColor"/>
   </output>
   <internal/>
   <include/>
   <code><![CDATA[
	  $(outColor) = color(xcomp($(inVector)),ycomp($(inVector)),zcomp($(inVector)) );
	  ]]></code>
   <offset x="-168" y="-148"/>
  </node>
  <node icon="" type="" author="mesh" id="19" name="ColorSpline" label="ColorSpline">
   <help>
Spline fits a spline to the control points given.  
At least four control points must always be given.  
If value equals 0, f2 (or c2, p2, v2) is returned; 
if value equals 1, fn (or cn, pn, vn) is returned.  
The type of the result depends on the type of the arguments.
  </help>
   <input>
    <property default="0.000" type="float" value="0.000" name="pattern" label="pattern"/>
    <property detail="uniform" default="7.000" type="float" value="7.000" name="numKnots" label="numKnots"/>
    <property detail="uniform" default="solvecatmull-rom" range="solvecatmull-rom:solvelinear" subtype="selector" type="string" value="solvecatmull-rom" name="knotsBasisFunction" label="knotsBasisFunction"/>
    <property detail="uniform" default="catmull-rom" range="catmull-rom:bezier:bspline:hermite:linear" subtype="selector" type="string" value="catmull-rom" name="colorsBasisFunction" label="colorsBasisFunction"/>
    <property default="0.000" type="float" value="0.000" name="k0" label="k0"/>
    <property default="color(0.000,0.000,0.000)" type="color" value="color(1.000,0.000,0.000)" name="c0" label="c0"/>
    <property default="0.000" type="float" value="0.000" name="k1" label="k1"/>
    <property default="color(0.000,0.000,0.000)" type="color" value="color(1.000,0.000,0.000)" name="c1" label="c1"/>
    <property default="0.000" type="float" value="0.100" name="k2" label="k2"/>
    <property default="color(0.000,0.000,0.000)" type="color" value="color(1.000,0.333,0.000)" name="c2" label="c2"/>
    <property default="0.000" type="float" value="0.300" name="k3" label="k3"/>
    <property default="color(0.000,0.000,0.000)" type="color" value="color(1.000,1.000,0.498)" name="c3" label="c3"/>
    <property default="0.000" type="float" value="0.500" name="k4" label="k4"/>
    <property default="color(0.000,0.000,0.000)" type="color" value="color(0.667,1.000,0.000)" name="c4" label="c4"/>
    <property default="0.000" type="float" value="0.800" name="k5" label="k5"/>
    <property default="color(0.000,0.000,0.000)" type="color" value="color(0.000,0.667,0.000)" name="c5" label="c5"/>
    <property default="1.000" type="float" value="1.000" name="k6" label="k6"/>
    <property default="color(1.000,1.000,1.000)" type="color" value="color(0.333,0.000,1.000)" name="c6" label="c6"/>
    <property default="1.000" type="float" value="1.000" name="k7" label="k7"/>
    <property default="color(1.000,1.000,1.000)" type="color" value="color(0.333,0.000,1.000)" name="c7" label="c7"/>
   </input>
   <output>
    <property default="color(0.000,0.000,0.000)" type="color" value="color(0.000,0.000,0.000)" name="out" label="out"/>
   </output>
   <internal>
    <variable name="k"/>
   </internal>
   <include/>
   <code><![CDATA[	
	  float $(k);
	  
  	$(k) = float spline( $(knotsBasisFunction), clamp( $(pattern), 0, 1), 
  			$(k0), $(k1), $(k2), $(k3), $(k4), $(k5),
  			$(k6), $(k7) );
  	    
    $(out) = color spline( $(colorsBasisFunction), $(k), 
  			$(c0), $(c1), $(c2), $(c3), $(c4), $(c5), 
  			$(c6), $(c7) );
  ]]></code>
   <offset x="-336" y="-418"/>
  </node>
  <node icon="" type="" author="mesh" id="20" name="Wipe" label="Wipe">
   <help></help>
   <input>
    <property default="1.000" type="float" value="1.000" name="input" label="input"/>
    <property default="S" range="S:T" subtype="selector" type="string" value="S" name="direction" label="direction"/>
    <property default="0.000" type="float" value="0.000" name="tspace" label="tspace"/>
    <property default="1.000" type="float" value="1.000" name="bspace" label="bspace"/>
    <property default="1.000" subtype="switch" type="float" value="0.000" name="invert" label="invert">
     <help>Performs an inversion of the results as defined by 1 - result. 
			Behavior will vary with the setting of the Abs and Clamp parameters.
		</help>
    </property>
    <property default="point(0.000,0.000,0.000)" type="point" value="point(0.000,0.000,0.000)" name="Q" label="Q"/>
    <property default="vector(0.000,0.000,0.000)" type="vector" value="vector(0.000,0.000,0.000)" name="dQu" label="dQu"/>
    <property default="vector(0.000,0.000,0.000)" type="vector" value="vector(0.000,0.000,0.000)" name="dQv" label="dQv"/>
   </input>
   <output>
    <property default="0.000" type="float" value="0.000" name="result" label="result"/>
   </output>
   <internal>
    <variable name="x"/>
    <variable name="y"/>
    <variable name="magnitude"/>
    <variable name="dampzone"/>
   </internal>
   <include/>
   <code><![CDATA[

  float $(x) = xcomp( $(Q) ); 
  float $(y) = ycomp( $(Q) ); 
  
  if ( $(direction) == "T" ) 
  {
    $(x) = ycomp( $(Q) ); 
    $(y) = xcomp( $(Q) ); 
  } 
    
  float $(magnitude) = $(input);
  float $(dampzone) = $(bspace) - $(tspace); 
  
  if ( $(y) > $(tspace) ) 
  { 
    if ( $(y) < ( $(tspace) + $(dampzone) ) )  
      $(magnitude) *= ( $(y) - $(tspace) ) / $(dampzone) ; 
  } 
  else
    $(magnitude) = 0;
  
  $(result) = $(magnitude); 
    
  if( $(invert) ) 
    $(result) = 1 - $(result);
             
	
]]></code>
   <offset x="-493" y="-267"/>
  </node>
  <node icon="" type="" author="Pixar" id="21" name="ST" label="ST">
   <help>Returns the 2D surface point based on the underlying\n
	    	ST parameterization of your object.</help>
   <input>
    <property detail="uniform" default="0.000" range="0 360 1" subtype="slider" type="float" value="0.000" name="angle" label="angle">
     <help></help>
    </property>
    <property detail="uniform" default="1.000" type="float" value="1.000" name="repeatS" label="repeatS">
     <help></help>
    </property>
    <property detail="uniform" default="1.000" type="float" value="1.000" name="repeatT" label="repeatT">
     <help></help>
    </property>
    <property detail="uniform" default="0.000" type="float" value="0.000" name="offsetS" label="offsetS">
     <help></help>
    </property>
    <property detail="uniform" default="0.000" type="float" value="0.000" name="offsetT" label="offsetT">
     <help></help>
    </property>
    <property detail="uniform" default="0.000" subtype="switch" type="float" value="0.000" name="flipS" label="flipS">
     <help></help>
    </property>
    <property detail="uniform" default="0.000" subtype="switch" type="float" value="0.000" name="flipT" label="flipT">
     <help></help>
    </property>
   </input>
   <output>
    <property default="point(0.000,0.000,0.000)" type="point" value="point(0.000,0.000,0.000)" name="Q" label="Q"/>
    <property default="vector(0.000,0.000,0.000)" type="vector" value="vector(0.000,0.000,0.000)" name="duQ" label="duQ"/>
    <property default="vector(0.000,0.000,0.000)" type="vector" value="vector(0.000,0.000,0.000)" name="dvQ" label="dvQ"/>
   </output>
   <internal/>
   <include/>
   <code><![CDATA[
		setxcomp( $(Q), $(repeatS) * s + $(offsetS));
    setycomp( $(Q), $(repeatT) * t + $(offsetT));
    setzcomp( $(Q), 0);
    
    if ( $(angle) != 0 )
      $(Q) = rotate($(Q), radians($(angle)), point(0,0,0), point(0,0,1)); 

    $(duQ) = vector Du( $(Q) ) * du;
    $(dvQ) = vector Dv( $(Q) ) * dv;
    
    if ( $(flipS) == 1 )
      setxcomp( $(Q), 1 - xcomp($(Q)) );
    if ( $(flipT) == 1 )
      setycomp( $(Q), 1 - ycomp($(Q)) );
  ]]></code>
   <offset x="-746" y="-169"/>
  </node>
  <node icon="" type="" author="mesh" id="22" name="Depthcue" label="Depthcue">
   <help></help>
   <input>
    <property default="1.000" subtype="switch" type="float" value="1.000" name="exponent" label="exponent"/>
    <property default="0.010" type="float" value="1.500" name="mindepth" label="mindepth"/>
    <property default="1000.000" type="float" value="2.500" name="maxdepth" label="maxdepth"/>
    <property default="1.000" subtype="switch" type="float" value="1.000" name="invert" label="invert">
     <help>Performs an inversion of the results as defined by 1 - result. 
			Behavior will vary with the setting of the Abs and Clamp parameters.
		</help>
    </property>
   </input>
   <output>
    <property default="0.000" type="float" value="0.000" name="result" label="result"/>
   </output>
   <internal>
    <variable name="z"/>
    <variable name="cP"/>
   </internal>
   <include/>
   <code><![CDATA[
	float $(z);
	
  point $(cP);
  $(cP) = transform("camera",P);
  
  if ( $(exponent) ) {
    $(z) = 1 - exp( ( $(mindepth) - zcomp($(cP)) )/($(maxdepth) - $(mindepth) ) );  
  } else {
    $(z) = ( zcomp( $(cP) ) - $(mindepth) )/( $(maxdepth) - $(mindepth) );
  }
    
  if ($(z) > 1) $(z) = 1;
  if ($(z) < 0) $(z) = 0;
  $(result) = 1 - $(z);
  if( $(invert) ) 
        $(result) = 1 - $(result);
  ]]></code>
   <offset x="-492" y="-414"/>
  </node>
  <node icon="" type="" author="Sler guys" id="33" name="voronoi2d" label="voronoi2d">
   <help>Standard voronoi 2D.</help>
   <input>
    <property default="20.000" type="float" value="20.000" name="freq" label="freq"/>
    <property default="1.000" type="float" value="1.000" name="jitter" label="jitter"/>
    <property default="0.000" type="float" value="0.000" name="s" label="s"/>
    <property default="0.000" type="float" value="0.000" name="t" label="t"/>
   </input>
   <output>
    <property default="0.000" type="float" value="0.000" name="f1" label="f1"/>
    <property default="0.000" type="float" value="0.000" name="pos_s" label="pos_s"/>
    <property default="0.000" type="float" value="0.000" name="pos_t" label="pos_t"/>
   </output>
   <internal>
    <variable name="P"/>
    <variable name="thiscell"/>
    <variable name="i"/>
    <variable name="j"/>
    <variable name="testcell"/>
    <variable name="pos"/>
    <variable name="offset"/>
    <variable name="dist"/>
   </internal>
   <include/>
   <code><![CDATA[
point $(P) = point($(s)*$(freq), $(t)*$(freq), 0);
point $(thiscell) = point(floor($(s)*$(freq))+0.5, floor($(t)*$(freq))+0.5, 0);

$(f1) = $(freq)+1;
uniform float $(i), $(j);
for ($(i)=-1; $(i)<=1; $(i)+=1)
{
    for ($(j)=-1; $(j)<=1; $(j)+=1)
    {
        point $(testcell) = $(thiscell) + vector($(i), $(j), 0);
        point $(pos) = $(testcell) + $(jitter)*(vector cellnoise($(testcell)) - 0.5);
        vector $(offset) = $(pos) - $(P);
        float $(dist) = $(offset).$(offset);

        if ($(dist) < $(f1))
        {
            $(f1) = $(dist);
            $(pos_s) = xcomp($(pos));
            $(pos_t) = ycomp($(pos));      
        }
    }
}

$(pos_s) /= $(freq);
$(pos_t) /= $(freq);

$(f1) = sqrt($(f1));
]]></code>
   <offset x="-809" y="284"/>
  </node>
  <node icon="" type="variable" author="Libero Spagnolini" id="34" name="s" label="s">
   <help>Renderer texture coordinate s.</help>
   <input/>
   <output>
    <property default="0.000" type="float" value="0.000" name="s" label="s"/>
   </output>
   <internal/>
   <include/>
   <code><![CDATA[
	  $(s) = s;
	  ]]></code>
   <offset x="-955" y="223"/>
  </node>
  <node icon="" type="variable" author="Libero Spagnolini" id="35" name="t" label="t">
   <help>Renderer texture coordinate t.</help>
   <input/>
   <output>
    <property default="0.000" type="float" value="0.000" name="t" label="t"/>
   </output>
   <internal/>
   <include/>
   <code><![CDATA[
	  $(t) = t;
	  ]]></code>
   <offset x="-954" y="286"/>
  </node>
  <node icon="" type="" author="mesh" id="36" name="Circle" label="Circle">
   <help>Generator of circle shape</help>
   <input>
    <property detail="uniform" default="0.000" range="Solid:Lineriar:Hemisphere" subtype="selector" type="float" value="0.000" name="FillType" label="Fill Type"/>
    <property default="0.300" range="0.01 0.5 .01" subtype="slider" type="float" value="0.300" name="Radius" label="Radius"/>
    <property detail="uniform" default="triangle" range="box:triangle:catmull-rom:gaussian" subtype="selector" type="string" value="triangle" name="Filter" label="Filter"/>
    <property detail="uniform" default="1.000" range="0 32 .1" subtype="slider" type="float" value="1.000" name="fwidth" label="Filter width"/>
    <property default="0.000" range="0 1 .01" subtype="slider" type="float" value="0.000" name="Fuzziness" label="Fuzziness"/>
    <property detail="uniform" default="0.000" subtype="switch" type="float" value="0.000" name="Invert" label="Invert"/>
    <property default="point(0.000,0.000,0.000)" type="point" value="point(0.000,0.000,0.000)" name="Q" label="Q"/>
    <property default="vector(0.000,0.000,0.000)" type="vector" value="vector(0.000,0.000,0.000)" name="duQ" label="duQ"/>
    <property default="vector(0.000,0.000,0.000)" type="vector" value="vector(0.000,0.000,0.000)" name="dvQ" label="dvQ"/>
   </input>
   <output>
    <property default="0.000" type="float" value="0.000" name="result" label="result"/>
   </output>
   <internal>
    <variable name="x"/>
    <variable name="y"/>
    <variable name="r"/>
    <variable name="dr"/>
    <variable name="rr"/>
   </internal>
   <include/>
   <code><![CDATA[
	float	$(x) = xcomp( $(Q) )-.5;
	float $(y) = ycomp( $(Q) )-.5;
	
	float	$(r) = sqrt ( $(x) * $(x) + $(y) * $(y) );
	
	$(x) = xcomp ( $(duQ) ) + xcomp ( $(dvQ) );
	$(y) = ycomp ( $(duQ) ) + ycomp ( $(dvQ) );
	
	float $(dr) = max ( .5 * $(Fuzziness), sqrt ( $(x) * $(x) + $(y) * $(y) ) );

	/* Solid */
	$(result) = 1 - filterstep ( $(Radius), $(r), $(r) + $(dr), "filter", $(Filter), "width", $(fwidth) );	
	
	if ( $(FillType) == 1.0 ) {	/* lineriar */
		$(result) = $(result) * ( ( $(Radius) - $(r) ) / $(Radius) );
	} else 
	  if ( $(FillType) == 2.0 ) {	/* Hemisphere  */
		float $(rr) = ( PI/2 ) * ( ( $(Radius) - $(r) ) / $(Radius) );
		$(result) *=  sin ( $(rr) ) ;
	}
	      		
	if( $(Invert) != 0 )
		$(result) = 1 - $(result);
  ]]></code>
   <offset x="-470" y="-71"/>
  </node>
  <node icon="" type="" author="Sler guys" id="37" name="marble" label="marble">
   <help>Marble semi fractal shader.</help>
   <input>
    <property default="color(0.800,0.200,0.050)" type="color" value="color(0.800,0.200,0.050)" name="inColor1" label="inColor1"/>
    <property default="color(0.800,0.800,0.790)" type="color" value="color(0.800,0.800,0.790)" name="inColor2" label="inColor2"/>
    <property default="2.500" type="float" value="2.500" name="veining" label="veining"/>
    <property default="point(0.000,0.000,0.000)" type="point" value="point(0.000,0.000,0.000)" name="P" label="P"/>
   </input>
   <output>
    <property default="color(0.000,0.000,0.000)" type="color" value="color(0.000,0.000,0.000)" name="outColor" label="outColor"/>
   </output>
   <internal>
    <variable name="surfaceColor"/>
    <variable name="layerColor"/>
    <variable name="layerOpac"/>
    <variable name="PP"/>
    <variable name="V"/>
    <variable name="Nf"/>
    <variable name="Nf"/>
    <variable name="width"/>
    <variable name="cutoff"/>
    <variable name="fade"/>
    <variable name="f"/>
    <variable name="turb"/>
    <variable name="maxfreq"/>
    <variable name="r"/>
    <variable name="g"/>
    <variable name="b"/>
   </internal>
   <include/>
   <code><![CDATA[
#define snoise(x)    (noise(x) * 2 - 1)
#define MINFILTERWIDTH  1e-7
#define filterwidth_point(p) (max(sqrt(area(p)), MINFILTERWIDTH))
#define blend(a,b,x) ((a) * (1 - (x)) + (b) * (x))

color $(surfaceColor), $(layerColor);
color $(layerOpac);
point $(PP);
vector $(V);
normal $(Nf) ;
float $(width), $(cutoff), $(fade), $(f), $(turb), $(maxfreq) = 16;

/* init */
$(surfaceColor) = 0;

$(Nf) = faceforward(normalize(N), I);
$(V) = -normalize(I);

/* compute turbulence */
$(PP) = $(P) * $(veining);

$(width) = filterwidth_point($(PP));
$(cutoff) = clamp(0.5 / $(width), 0, $(maxfreq));

$(turb) = 0;
for($(f) = 1; $(f) < 0.5 * $(cutoff); $(f) *= 2) 
    $(turb) += abs(snoise($(PP) * $(f))) / $(f);
$(fade) = clamp(2 * ($(cutoff) - $(f)) / $(cutoff), 0, 1);
$(turb) += $(fade) * abs(snoise($(PP) * $(f))) / $(f);

$(turb) *= 0.5;  /* to match original rmarble turbulence value */

/* use turb to index into spline for layer color */

float $(r) = comp($(inColor1), 0);
float $(g) = comp($(inColor1), 1);
float $(b) = comp($(inColor1), 2);

$(layerColor) = spline($(turb),
        		       $(inColor1),
        		       $(inColor1),
        		       color($(r), $(g)+0.3, $(b)+0.25),
        		       color($(r)-0.2, $(g)+0.394, $(b)+0.53),
        		       color($(r)-0.5, $(g)+0.1, $(b)+0.35),
        		       color($(r)-0.75, $(g)+0.15, $(b)+0.05),
        		       $(inColor2),
        		       $(inColor2)); 
		       
$(layerOpac) = 1;
$(surfaceColor) = blend($(surfaceColor), $(layerColor), $(layerOpac));

$(outColor) = $(surfaceColor);
]]></code>
   <offset x="-652" y="357"/>
  </node>
  <node icon="" type="" author="Alexei Puzikov" id="42" name="blinn" label="blinn">
   <help>Blinn illumination model.</help>
   <input>
    <property default="color(0.000,0.500,1.000)" type="color" value="color(0.000,0.500,1.000)" name="SurfaceColor" label="SurfaceColor"/>
    <property default="0.800" type="float" value="0.800" name="diffuseCoeff" label="diffuseCoeff"/>
    <property default="color(0.000,0.000,0.000)" type="color" value="color(0.000,0.000,0.000)" name="ambientColor" label="ambientColor"/>
    <property default="color(0.000,0.000,0.000)" type="color" value="color(0.000,0.000,0.000)" name="incandescence" label="incandescence"/>
    <property default="0.000" type="float" value="0.000" name="translucence" label="translucence"/>
    <property default="color(0.500,0.500,0.500)" type="color" value="color(0.500,0.500,0.500)" name="specularColor" label="specularColor"/>
    <property default="0.300" type="float" value="0.300" name="eccentricity" label="eccentricity"/>
    <property default="0.700" type="float" value="0.700" name="specularRollOff" label="specularRollOff"/>
   </input>
   <output>
    <property default="color(0.000,0.000,0.000)" type="color" value="color(0.000,0.000,0.000)" name="outColor" label="outColor"/>
   </output>
   <internal>
    <variable name="Nf"/>
    <variable name="H"/>
    <variable name="Ln"/>
    <variable name="E"/>
    <variable name="V"/>
    <variable name="Ia"/>
    <variable name="Id"/>
    <variable name="Itr"/>
    <variable name="Is"/>
    <variable name="NH"/>
    <variable name="NH2"/>
    <variable name="NHSQ"/>
    <variable name="Dd"/>
    <variable name="Gg"/>
    <variable name="VN"/>
    <variable name="VH"/>
    <variable name="LN"/>
    <variable name="Ff"/>
    <variable name="tmp"/>
   </internal>
   <include/>
   <code><![CDATA[ 
 normal $(Nf);
 vector $(H), $(Ln), $(V);
 color $(Ia), $(Id), $(Itr), $(Is);
 float $(NH), $(NH2), $(NHSQ), $(Dd), $(Gg), $(VN), $(VH), $(LN), $(Ff), $(tmp);
 float $(E)= 1 / ($(eccentricity) * $(eccentricity)- 1);
  
 $(Nf)= faceforward(normalize(N), I);
 $(Ia)= ambient() + $(ambientColor);
 $(Id)= $(diffuseCoeff)* diffuse($(Nf));
 
 $(Itr)= 0;
 if ($(translucence)!= 0) {
  illuminance(P, $(Nf), PI)
  $(Itr)+= Cl;
  $(Itr)*= $(translucence);
 }
 
 $(Is)= 0;
 $(V)= normalize(-I);
 $(VN)= $(V).$(Nf);
 illuminance(P, $(Nf), PI * 0.5) {
  $(Ln)= normalize(L);
  $(H)= normalize($(Ln)+$(V));
  $(NH)= $(Nf).$(H);
  $(NHSQ)= $(NH)*$(NH);
  $(NH2)= $(NH)* 2;
  $(Dd)= ($(E)+1) / ($(NHSQ)+ $(E));
  $(Dd)*= $(Dd);
  $(VH)= $(V).$(H);
  $(LN)= $(Ln).$(Nf);
  if ($(VN) < $(LN)) {
   if ($(VN)* $(NH2) < $(VH))
   $(Gg)= $(NH2)/ $(VH);
   else
   $(Gg)= 1 / $(VN);
   }
  else {
   if ($(LN)* $(NH2) < $(VH))
   $(Gg)= ($(LN)* $(NH2)) / ($(VH)* $(VN));
  else
  $(Gg)= 1 / $(VN);
 }
 $(tmp)= pow((1 - $(VH)), 3);
 $(Ff)= $(tmp)+ (1 - $(tmp)) * $(specularRollOff);
 $(Is)+= Cl * $(Dd)* $(Gg)* $(Ff);
 }
 $(Is)*= $(specularColor);
 
 $(outColor)= $(SurfaceColor)* ($(Ia) + $(Id) + $(Itr) + $(incandescence)+ $(Is));
]]></code>
   <offset x="-329" y="15"/>
  </node>
  <node icon="" type="" author="Alexei Puzikov" id="43" name="lambert" label="lambert">
   <help>Lambert illumination model.</help>
   <input>
    <property default="color(0.000,0.500,1.000)" type="color" value="color(0.000,0.500,1.000)" name="SurfaceColor" label="SurfaceColor"/>
    <property default="0.800" type="float" value="0.800" name="diffuseCoeff" label="diffuseCoeff"/>
    <property default="color(0.000,0.000,0.000)" type="color" value="color(0.000,0.000,0.000)" name="ambientColor" label="ambientColor"/>
    <property default="color(0.000,0.000,0.000)" type="color" value="color(0.000,0.000,0.000)" name="incandescence" label="incandescence"/>
    <property default="0.000" type="float" value="0.000" name="translucence" label="translucence"/>
   </input>
   <output>
    <property default="color(0.000,0.000,0.000)" type="color" value="color(0.000,0.000,0.000)" name="outColor" label="outColor"/>
   </output>
   <internal>
    <variable name="Nf"/>
    <variable name="V"/>
    <variable name="Ia"/>
    <variable name="Id"/>
    <variable name="Itr"/>
   </internal>
   <include/>
   <code><![CDATA[
 normal $(Nf)= faceforward( normalize(N), I );
 vector $(V)= -normalize(I);
 color $(Ia)= ambient() + $(ambientColor);
 color $(Id)= $(diffuseCoeff)* diffuse($(Nf));
 
 color $(Itr)= 0;
 if ($(translucence)!= 0) {
  illuminance(P, $(Nf), PI)
  $(Itr)+= Cl;
  $(Itr)*= $(translucence);
 }
 
 $(outColor)= $(SurfaceColor) * ($(Ia)+ $(Id)+ $(Itr)+ $(incandescence));
 ]]></code>
   <offset x="-203" y="-22"/>
  </node>
  <node icon="" type="" author="Fredrik Gustafsson" id="45" name="toon" label="toon">
   <help>Toon Antialising Shader.</help>
   <input>
    <property default="0.250" type="float" value="0.000" name="Ka" label="Ka"/>
    <property default="0.670" type="float" value="0.900" name="Kd" label="Kd"/>
    <property default="35.000" type="float" value="0.300" name="Ks" label="Ks"/>
    <property default="0.080" type="float" value="0.001" name="roughness" label="roughness"/>
    <property default="color(1.000,1.000,1.000)" type="color" value="color(1.000,1.000,1.000)" name="specularcolor" label="specularcolor"/>
    <property default="color(0.000,0.500,1.000)" type="color" value="color(0.000,0.500,1.000)" name="paint_color" label="paint_color"/>
    <property default="0.920" type="float" value="0.800" name="paint_spec" label="paint_spec"/>
    <property default="0.350" type="float" value="0.350" name="paint_trans" label="paint_trans"/>
    <property default="0.025" type="float" value="0.025" name="paint_fuzz" label="paint_fuzz"/>
    <property default="0.230" type="float" value="0.400" name="ink_thresh" label="ink_thresh"/>
    <property default="0.020" type="float" value="0.020" name="ink_fuzz" label="ink_fuzz"/>
    <property default="color(0.050,0.050,0.050)" type="color" value="color(0.050,0.050,0.050)" name="ink_color" label="ink_color"/>
   </input>
   <output>
    <property default="color(0.000,0.000,0.000)" type="color" value="color(0.000,0.000,0.000)" name="toonCi" label="toonCi"/>
    <property default="color(0.000,0.000,0.000)" type="color" value="color(0.000,0.000,0.000)" name="toonOi" label="toonOi"/>
   </output>
   <internal>
    <variable name="toonspec"/>
    <variable name="cos_here"/>
    <variable name="diff"/>
    <variable name="spec"/>
    <variable name="Nf"/>
    <variable name="normI"/>
    <variable name="half"/>
    <variable name="toon_color"/>
    <variable name="layer_color"/>
    <variable name="toon_opac"/>
    <variable name="layer_opac"/>
   </internal>
   <include/>
   <code><![CDATA[
#define blend(a,b,x) ((a) * (1 - (x)) + (b) * (x))
#define union(a,b) ((a) + (b) - (a) * (b))

float
$(toonspec)(vector N, V; float roughness)
{
  extern point P;  
  extern vector L;
  float C = 0;
  vector H;
  
  illuminance ( P, N, PI/2 ) 
  {
    H = normalize( normalize( L )+V );
    C += pow(N.H, 1/roughness);
  }
  return C;
}

  float $(cos_here);
  float $(diff), $(spec);
  normal $(Nf);
  vector $(normI), $(half);

  color $(toon_color), $(layer_color);
  color $(toon_opac), $(layer_opac);

  $(Nf)= faceforward(normalize(N), I);
  $(normI)= normalize(I);

  /* background layer (layer 0) */
  $(toon_color)= color (0, 0, 0);
  $(toon_opac)= Os;

  /* toon paint (layer 1) */

  /* only care about percentage illumination */
  $(diff)= 0;
  illuminance ( P, $(Nf), PI/2 )
    $(diff) += normalize(L).$(Nf); 

  /* antialias the transition */
  $(diff)= smoothstep($(paint_trans)- $(paint_fuzz)/2, $(paint_trans)+ $(paint_fuzz)/2, $(diff));

  /* specular -- transition also antialiased */  
  $(spec)= $(toonspec)($(Nf), -normalize(I), $(roughness));
  $(spec)= smoothstep($(paint_spec)- $(paint_fuzz)/2, $(paint_spec)+ $(paint_fuzz)/2, $(spec));

  $(layer_color)= Cs*($(Kd)*$(diff)*$(paint_color)+ $(Ka)*ambient()) + $(specularcolor)*$(Ks)*$(spec);
  $(layer_opac)= Os;

  $(toon_color)= blend($(toon_color), $(layer_color), $(layer_opac));
  $(toon_opac)=  union($(toon_opac), $(layer_opac));

  /* toon ink (layer 3) */
  
  $(cos_here)= normalize($(Nf)).$(normI);

  /* antialias ink lines */
  $(layer_opac)= 1 - smoothstep($(ink_thresh)- $(ink_fuzz)/2, $(ink_thresh)+ $(ink_fuzz)/2, abs($(cos_here)));
  
  if (abs($(cos_here)) < $(ink_thresh))
    $(layer_color)= $(ink_color);
  else
    $(layer_color)= 0;
  
  $(toon_color)= blend($(toon_color), $(layer_color), $(layer_opac));
  $(toon_opac)=  union($(toon_opac), $(layer_opac));

  $(toonOi)= $(toon_opac);
  $(toonCi)= $(toon_opac) * $(toon_color);
]]></code>
   <offset x="-365" y="227"/>
  </node>
  <node icon="" type="" author="Simon Bunker" id="46" name="xray" label="xray">
   <help>Simple xray surface shader; assign it to Oi.</help>
   <input>
    <property default="1.000" type="float" value="1.000" name="edgefalloff" label="edgefalloff"/>
   </input>
   <output>
    <property default="color(0.000,0.000,0.000)" type="color" value="color(0.000,0.000,0.000)" name="outOpacity" label="outOpacity"/>
   </output>
   <internal>
    <variable name="opac"/>
   </internal>
   <include/>
   <code><![CDATA[
float $(opac) = pow ( abs(normalize(N).normalize(I)), $(edgefalloff) );
$(outOpacity)= ( 1 - $(opac) ) * Oi;
]]></code>
   <offset x="-180" y="146"/>
  </node>
  <node icon="" type="rsl_code" author="Ivan DeWolf" id="47" name="IDbubbly" label="IDbubbly">
   <help>bubbly.sl written a while ago by Ivan DeWolf ivan@martian-tools.com
    		basicly it is F1 squared as described in a cellular texture basis function
    		by Steven Worley in the siggraph proceedings from 1996, except this uses a noised grid of cells
    		instead of the sparse convolution in the paper. not as elegant, but hey, it works.
    		the bubbles are paraboloids diplaced along the normal. </help>
   <input>
    <property default="point(0.000,0.000,0.000)" type="point" value="point(0.000,0.000,0.000)" name="P" label="P"/>
    <property default="normal(0.000,1.000,0.000)" type="normal" value="normal(0.000,1.000,0.000)" name="N" label="N"/>
    <property default="0.200" type="float" value="0.200" name="Kd" label="Kd"/>
    <property default="5.000" type="float" value="5.000" name="mult" label="mult"/>
    <property default="1.000" type="float" value="1.000" name="Nzscale" label="Nzscale"/>
    <property default="1.000" type="float" value="1.000" name="bubsize" label="bubsize"/>
   </input>
   <output>
    <property default="point(0.000,0.000,0.000)" type="point" value="point(0.000,0.000,0.000)" name="outP" label="outP"/>
    <property default="normal(0.000,0.000,0.000)" type="normal" value="normal(0.000,0.000,0.000)" name="outN" label="outN"/>
   </output>
   <internal>
    <variable name="Nn"/>
    <variable name="a"/>
    <variable name="b"/>
    <variable name="c"/>
    <variable name="bub"/>
    <variable name="dist"/>
    <variable name="shortest"/>
    <variable name="Po"/>
    <variable name="trucell"/>
    <variable name="surrcell"/>
    <variable name="nzcell"/>
    <variable name="offset"/>
   </internal>
   <include/>
   <code><![CDATA[
	  normal $(Nn) = normalize($(N));
    float $(a), $(b), $(c), $(bub);
    float $(dist), $(shortest)=10000;
    
    point $(Po) = transform( "object", $(P) ) * $(mult);
  
    /* true cell center, surrounding cell centers, noised cell center */
    point $(trucell), $(surrcell), $(nzcell);
    vector $(offset);
    
    setxcomp ( $(trucell), floor ( xcomp ( $(Po) ) ) + .5 );
    setycomp ( $(trucell) ,floor ( ycomp ( $(Po) ) ) + .5 );
    setzcomp ( $(trucell), floor ( zcomp ( $(Po) ) ) + .5 );
  			     
    /* what is the shortest distance to a noised cell center? */
    for ( $(a) = -1 ; $(a) <= 1 ; $(a) += 1 ) 
    {
      for ( $(b) = -1 ; $(b) <= 1 ; $(b) += 1 )
      {
        for ( $(c) = -1 ; $(c) <= 1 ; $(c) += 1 )
        {
        	$(offset) = vector ( $(a), $(b), $(c) );
        	$(surrcell) = $(trucell) + $(offset);
        	$(nzcell) = $(surrcell) + ( ( vector cellnoise ( $(surrcell) ) - .5) * $(Nzscale) );
        	$(dist) = distance ( $(Po), $(nzcell) );
        	if ( $(dist) < $(shortest) ) 
        	  $(shortest) = $(dist);
        }
      }
    }
    $(bub) = clamp ( $(shortest), 0, $(bubsize) ) / $(bubsize); 
    $(P) += $(Nn) * ( pow ( $(bub), 2 ) - 1 ) * $(Kd);
    $(N) = calculatenormal ( $(P) );
          
	  $(outP) = $(P); 
	  $(outN) = $(N);
	  ]]></code>
   <offset x="-319" y="-632"/>
  </node>
  <node icon="" type="variable" author="mesh" id="48" name="P" label="P">
   <help>Global point P.</help>
   <input/>
   <output>
    <property default="point(0.000,0.000,0.000)" type="point" value="point(0.000,0.000,0.000)" name="P" label="P"/>
   </output>
   <internal/>
   <include/>
   <code><![CDATA[
	  #ifdef SURFACE_SHADER
	  $(P) = P;
	  #endif
	  #ifdef DISPLACEMENT_SHADER
	  $(P) = P;
	  #endif
	  #ifdef LIGHT_SHADER
	  $(P) = Ps;
	  #endif
	  #ifdef VOLUME_SHADER
	  $(P) = Pv;
	  #endif
	  ]]></code>
   <offset x="-474" y="-623"/>
  </node>
  <node icon="" type="variable" author="mesh" id="49" name="N" label="N">
   <help>Global normal N.</help>
   <input/>
   <output>
    <property default="normal(0.000,0.000,0.000)" type="normal" value="normal(0.000,0.000,0.000)" name="N" label="N"/>
   </output>
   <internal/>
   <include/>
   <code><![CDATA[
	#ifdef SURFACE_SHADER
	  $(N) = N;
	  #endif
	  #ifdef DISPLACEMENT_SHADER
	  $(N) = N;
	  #endif
	  #ifdef LIGHT_SHADER
	  $(N) = Ns;
	  #endif
	  #ifdef VOLUME_SHADER
	  $(N) = Nv;
	  #endif
	]]></code>
   <offset x="-473" y="-562"/>
  </node>
  <node icon="" type="displacement" author="mesh" id="50" name="displace" label="displace">
   <help>Root displacement shader.</help>
   <input>
    <property default="point(0.000,0.000,0.000)" type="point" value="point(0.000,0.000,0.000)" name="P" label="P"/>
    <property default="normal(0.000,1.000,0.000)" type="normal" value="normal(0.000,1.000,0.000)" name="N" label="N"/>
   </input>
   <output>
    <property default="${NODELABEL}" type="displacement" value="${NODELABEL}" name="disp" label="disp"/>
   </output>
   <internal/>
   <include/>
   <code><![CDATA[
	  P = $(P); 
	  N = $(N);
	]]></code>
   <offset x="-155" y="-295"/>
  </node>
 </nodes>
 <links>
  <link srcNode_id="1" dstNode_id="2" id="1" srcParam="ImageFile" dstParam="image"/>
  <link srcNode_id="3" dstNode_id="1" id="2" srcParam="rib" dstParam="Globals"/>
  <link srcNode_id="21" dstNode_id="20" id="37" srcParam="Q" dstParam="Q"/>
  <link srcNode_id="21" dstNode_id="20" id="38" srcParam="duQ" dstParam="dQu"/>
  <link srcNode_id="21" dstNode_id="20" id="39" srcParam="dvQ" dstParam="dQv"/>
  <link srcNode_id="20" dstNode_id="19" id="40" srcParam="result" dstParam="pattern"/>
  <link srcNode_id="34" dstNode_id="33" id="76" srcParam="s" dstParam="s"/>
  <link srcNode_id="35" dstNode_id="33" id="77" srcParam="t" dstParam="t"/>
  <link srcNode_id="21" dstNode_id="36" id="79" srcParam="Q" dstParam="Q"/>
  <link srcNode_id="21" dstNode_id="36" id="80" srcParam="duQ" dstParam="duQ"/>
  <link srcNode_id="21" dstNode_id="36" id="81" srcParam="dvQ" dstParam="dvQ"/>
  <link srcNode_id="7" dstNode_id="37" id="83" srcParam="Q" dstParam="P"/>
  <link srcNode_id="46" dstNode_id="4" id="99" srcParam="outOpacity" dstParam="Ci"/>
  <link srcNode_id="49" dstNode_id="47" id="100" srcParam="N" dstParam="N"/>
  <link srcNode_id="48" dstNode_id="47" id="101" srcParam="P" dstParam="P"/>
  <link srcNode_id="47" dstNode_id="50" id="102" srcParam="outP" dstParam="P"/>
  <link srcNode_id="47" dstNode_id="50" id="103" srcParam="outN" dstParam="N"/>
  <link srcNode_id="50" dstNode_id="1" id="104" srcParam="disp" dstParam="FG_disp"/>
  <link srcNode_id="4" dstNode_id="1" id="105" srcParam="surface" dstParam="FG_surf"/>
 </links>
</nodenet>
