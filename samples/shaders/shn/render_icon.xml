<!DOCTYPE render_icon>
<nodenet author="meShaderEd" name="render_icon">
 <help>Short NodeNetwork description</help>
 <nodes>
  <node icon="" type="rib" author="mesh" id="1" name="BasicPrimitive" label="BasicPrimitive">
   <help>Basic primitive preview RIB</help>
   <input>
    <property default="" type="rib" value="" name="Globals" label="Render Options"/>
    <property provider="attribute" default="Sphere" range="Sphere:Teapot:Cylinder:Torus:Plane" subtype="selector" type="string" value="Teapot" name="Primitive" label="Primitive"/>
    <property provider="attribute" default="256" type="int" value="128" name="Width" label="Image width"/>
    <property provider="attribute" default="256" type="int" value="128" name="Height" label="Image height"/>
    <property provider="attribute" default="1.250" type="float" value="0.000" name="EnvIntensity" label="EnvLight Intensity"/>
    <property provider="attribute" default="kitchen_LL.hdr.${TEX}" range="All files=*.*:TEX=*.tex:TDL=*.tdl:TIFF=*.tif" subtype="file" type="string" value="kitchen_LL.hdr.${TEX}" name="EnvMap" label="Environment Map"/>
    <property provider="attribute" default="0.000 0.000 1.000" type="color" value="0.000 0.000 1.000" name="Color" label="Color"/>
    <property provider="attribute" default="1.000 1.000 1.000" type="color" value="1.000 1.000 1.000" name="Opacity" label="Opacity"/>
    <property default="null" type="displacement" value="null" name="FG_disp" label="Displace Shader"/>
    <property provider="attribute" default="0.500" type="float" value="0.500" name="DisplaceBound" label="Displacement Bound"/>
    <property default="defaultsurface" type="surface" value="defaultsurface" name="FG_surf" label="Surface Shader"/>
    <property default="liquidchecker" type="surface" value="liquidchecker" name="BG_surf" label="Background Shader"/>
    <property display="hidden" provider="attribute" default="" type="string" value="&#xa;      Rotate 0 0 1 0&#xa;      AttributeBegin&#xa;        Scale 0.35 0.35 0.35&#xa;        Translate -0.6 -1 0&#xa;        Rotate 120 -1 0 0&#xa;        Rotate 30 0 0 1&#xa;        Geometry &quot;teapot&quot;&#xa;      AttributeEnd&#xa;      " name="PrimitiveCode" label="PrimitiveCode"/>
   </input>
   <output>
    <property default="${TempPath}/${NODELABEL}.tif" type="image" value="${TempPath}/${NODELABEL}.tif" name="ImageFile" label="ImageFile"/>
   </output>
   <internal/>
   <include/>
   <param_code><![CDATA[
print ":: Hello from %s XML code !!!" % self.label

if self.getInputParamByName ( 'Primitive' ).value == 'Sphere': 
  self.getInputParamByName ( 'PrimitiveCode' ).value = "Rotate 60 1 0 0\n Sphere 1.0 -1.0 1.0 360"
  
if self.getInputParamByName ( 'Primitive' ).value == 'Teapot': 
  self.getInputParamByName ( 'PrimitiveCode' ).value = """
      Rotate 0 0 1 0
      AttributeBegin
        Scale 0.35 0.35 0.35
        Translate -0.6 -1 0
        Rotate 120 -1 0 0
        Rotate 30 0 0 1
        Geometry \"teapot\"
      AttributeEnd
      """
      
if self.getInputParamByName ( 'Primitive' ).value == 'Cylinder': 
  self.getInputParamByName ( 'PrimitiveCode' ).value = "Rotate 60 1 0 0\n Cylinder 1 -0.5 0.5 360"
  
if self.getInputParamByName ( 'Primitive' ).value == 'Torus': 
  self.getInputParamByName ( 'PrimitiveCode' ).value = """
  Rotate 45 1 0 0
  Torus 0.7 0.4 0.0 360 360
  """

if self.getInputParamByName ( 'Primitive' ).value == 'Plane': 
  self.getInputParamByName ( 'PrimitiveCode' ).value = 'Patch "bilinear" "P" [-1 1 0 1 1 0 -1 -1 0 1 -1 0]'


]]></param_code>
   <code><![CDATA[
  Option "searchpath" "shader" "&:@:.:~:${ShaderSearchPath}:${ProjectSearchPath}:${ProjectSearchShaders}"
  Option "searchpath" "texture" "&:@:.:~:${TextureSearchPath}:${ProjectSearchPath}:${ProjectSearchTextures}"

  $(Globals)

  ### Output image
  Display "$(ImageFile)" "tiff" "rgba"

  Format $(Width) $(Height) 1.0

  Projection "perspective" "fov" 45
  Translate 0 0 3.0

  Attribute "displacementbound" "float sphere" [$(DisplaceBound)]

  WorldBegin

    ReverseOrientation 
	
    TransformBegin
      Rotate -90 1 0 0
      CoordinateSystem "_environment"
    TransformEnd

    LightSource "distantlight" 1 "intensity" 1.0 "from" [-2 2 -3] "to" [0 0 0]
    LightSource "distantlight" 2 "intensity" 0.4 "from" [6 -3 0] "to" [0 0 0]
    LightSource "meEnvLight" 3  "uniform float Intensity" [$(EnvIntensity)] 
                                "uniform string meEnvMap_EnvMap" ["$(EnvMap)"]
                                "uniform string meEnvMap_Space" ["_environment"]

    AttributeBegin 
      
      
      
      Color [$(Color)]
      Opacity [$(Opacity)]

      Displacement "$(FG_disp)"
      Surface "$(FG_surf)" 
      
      $(PrimitiveCode)
      
    AttributeEnd 
      
    AttributeBegin 
      Scale 7 7 7
      Translate 0 0 2
      Surface "$(BG_surf)" 
      
      Patch "bilinear" "P" [-1 1 0 1 1 0 -1 -1 0 1 -1 0]
    AttributeEnd  

  WorldEnd
  ]]></code>
   <offset x="121" y="-307"/>
  </node>
  <node icon="" type="image" author="mesh" id="2" name="imageViewer" label="imageViewer">
   <help>Single image viewer </help>
   <input>
    <property default="" range="All files=*.*:TIFF=*.tif:PNG=*.png:JPEG=*.jpg" subtype="file" type="image" value="" name="image" label="image"/>
   </input>
   <output/>
   <internal/>
   <include/>
   <param_code><![CDATA[
#$(output) = $(input)
#import core.imageNode
#import code.nodeParam

print ":: Hello from %s XML code !!!" % self.label
self.imageName = self.getInputParamValueByName ( 'image' ) 


]]></param_code>
   <offset x="279" y="-278"/>
  </node>
  <node icon="" type="rib_code" author="mesh" id="3" name="RenderGlobals" label="RenderGlobals">
   <help>RenderGlobals options</help>
   <input>
    <property provider="attribute" default="hidden" range="hidden:raytrace:photon:zbuffer:opengl" subtype="selector" type="string" value="hidden" name="Hider" label="Hider"/>
    <property provider="attribute" default="1" subtype="switch" type="int" value="1" name="Jitter" label="Jitter"/>
    <property provider="attribute" default="1.000" type="float" value="0.100" name="ShadingRate" label="Shading rate"/>
    <property provider="attribute" default="4" type="int" value="6" name="Samples" label="Samples"/>
    <property provider="attribute" default="catmull-rom" range="box:triangle:catmull-rom:gaussian:sinc:blackman-harris:mitchell:separable-catmull-rom:lanczos:bessel" subtype="selector" type="string" value="catmull-rom" name="Filter" label="Filter"/>
    <property provider="attribute" default="2.000" type="float" value="2.000" name="FilterWidth" label="Filter width"/>
    <property default="" type="rib" value="" name="Options" label="Options"/>
   </input>
   <output>
    <property default="" type="rib" value="" name="rib" label="rib"/>
   </output>
   <internal/>
   <include/>
   <code><![CDATA[
  ##Option "searchpath" "shader" "&:@:.:~:${ShaderSearchPath}:${ProjectSearchPath}:${ProjectSearchShaders}"
  ##Option "searchpath" "texture" "&:@:.:~:${TextureSearchPath}:${ProjectSearchPath}:${ProjectSearchTextures}"

  Hider "hidden" "int jitter" [1]

  PixelSamples $(Samples) $(Samples)
  PixelFilter "$(Filter)" $(FilterWidth) $(FilterWidth)
  ShadingRate $(ShadingRate)

  $(Options)
  ]]></code>
   <offset x="-96" y="-440"/>
  </node>
  <node icon="" type="surface" author="mesh" id="4" name="surface" label="surf">
   <help>Basic surface shader.</help>
   <input>
    <property default="color(0.000,0.000,0.000)" type="color" value="color(0.000,0.000,0.000)" name="Ci" label="Ci"/>
    <property default="color(1.000,1.000,1.000)" type="color" value="color(1.000,1.000,1.000)" name="Oi" label="Oi"/>
   </input>
   <output>
    <property default="${NODELABEL}" type="surface" value="${NODELABEL}" name="surface" label="surface"/>
   </output>
   <internal/>
   <include/>
   <code><![CDATA[
	  Ci = $(Ci) * $(Oi); 
	  Oi = $(Oi);
	]]></code>
   <offset x="-15" y="-154"/>
  </node>
  <node icon="" type="rsl_code" author="" id="5" name="floatToColor" label="floatToColor">
   <help>Float to color converter.</help>
   <input>
    <property default="1.000" type="float" value="1.000" name="inFloat" label="inFloat"/>
   </input>
   <output>
    <property default="color(0.000,0.000,0.000)" type="color" value="color(0.000,0.000,0.000)" name="outColor" label="outColor"/>
   </output>
   <internal/>
   <include/>
   <code><![CDATA[
	  $(outColor) = color($(inFloat), $(inFloat), $(inFloat));
	  ]]></code>
   <offset x="101" y="242"/>
  </node>
  <node icon="" type="" author="Pixar" id="7" name="SurfaceP" label="SurfaceP">
   <help>Returns the 3D point on the surface of your object.</help>
   <input>
    <property detail="uniform" default="" type="string" value="" name="Space" label="Space">
     <help>The name of a coordinate system for the manifold.
		    In addition to your custom coordinate systems
		    you can use "current", "world", "object", "shader"
		    and "NDC" (screen coordinates).</help>
    </property>
    <property default="1.000" range="0 10 .001" subtype="slider" type="float" value="1.000" name="Frequency" label="Frequency">
     <help>Controls the scale of the manifold.  Note
		    that increasing the frequency of the manifold will result
		    in decreasing the scale of a feature.</help>
    </property>
    <property default="1.000" subtype="switch" type="float" value="1.000" name="IgnorePref" label="IgnorePref">
     <help>If you have attached __Pref geometry and,
		    for debugging purposes, want to ignore it, click
		    here.  Note that it's much more efficient to simply
		    remove the reference geometry if it's not needed.</help>
    </property>
    <property detail="varying" provider="primitive" default="point(-1.000,-1.000,-1.000)" type="point" value="point(-1.000,-1.000,-1.000)" name="__Pref" label="__Pref"/>
   </input>
   <output>
    <property default="point(0.000,0.000,0.000)" type="point" value="point(0.000,0.000,0.000)" name="Q" label="Q"/>
    <property default="vector(0.000,0.000,0.000)" type="vector" value="vector(0.000,0.000,0.000)" name="duQ" label="duQ"/>
    <property default="vector(0.000,0.000,0.000)" type="vector" value="vector(0.000,0.000,0.000)" name="dvQ" label="dvQ"/>
   </output>
   <internal>
    <variable name="sys"/>
   </internal>
   <include/>
   <code><![CDATA[

	uniform string $(sys);
	
	if ( $(Space) == "" )
    $(sys) = "shader";
  else
    $(sys) = $(Space);
      
  if ( xcomp(__Pref) == -1e10 || $(IgnorePref) != 0 )
  {
    $(Q) = $(Frequency) * transform( $(sys), P );
  	$(duQ) = vtransform( $(sys), dPdu * du * $(Frequency) );
  	$(dvQ) = vtransform( $(sys), dPdv * dv * $(Frequency) );
  }
  else 
  {
    $(Q) = $(Frequency) * transform( $(sys), __Pref );
    $(duQ) = vector Du( $(Q) ) * du;
    $(dvQ) = vector Dv( $(Q) ) * dv;
  }
	]]></code>
   <offset x="-776" y="73"/>
  </node>
  <node icon="" type="rsl_code" author="" id="11" name="vectorToColor" label="vectorToColor">
   <help>Vector to color converter.</help>
   <input>
    <property default="vector(0.000,0.000,0.000)" type="vector" value="vector(0.000,0.000,0.000)" name="inVector" label="inVector"/>
   </input>
   <output>
    <property default="color(0.000,0.000,0.000)" type="color" value="color(0.000,0.000,0.000)" name="outColor" label="outColor"/>
   </output>
   <internal/>
   <include/>
   <code><![CDATA[
	  $(outColor) = color(xcomp($(inVector)),ycomp($(inVector)),zcomp($(inVector)) );
	  ]]></code>
   <offset x="93" y="356"/>
  </node>
  <node icon="" type="" author="mesh" id="19" name="ColorSpline" label="ColorSpline">
   <help>
Spline fits a spline to the control points given.  
At least four control points must always be given.  
If value equals 0, f2 (or c2, p2, v2) is returned; 
if value equals 1, fn (or cn, pn, vn) is returned.  
The type of the result depends on the type of the arguments.
  </help>
   <input>
    <property default="0.000" type="float" value="0.000" name="pattern" label="pattern"/>
    <property detail="uniform" default="7.000" type="float" value="7.000" name="numKnots" label="numKnots"/>
    <property detail="uniform" default="solvecatmull-rom" range="solvecatmull-rom:solvelinear" subtype="selector" type="string" value="solvecatmull-rom" name="knotsBasisFunction" label="knotsBasisFunction"/>
    <property detail="uniform" default="catmull-rom" range="catmull-rom:bezier:bspline:hermite:linear" subtype="selector" type="string" value="catmull-rom" name="colorsBasisFunction" label="colorsBasisFunction"/>
    <property default="0.000" type="float" value="0.000" name="k0" label="k0"/>
    <property default="color(0.000,0.000,0.000)" type="color" value="color(1.000,0.000,0.000)" name="c0" label="c0"/>
    <property default="0.000" type="float" value="0.000" name="k1" label="k1"/>
    <property default="color(0.000,0.000,0.000)" type="color" value="color(1.000,0.000,0.000)" name="c1" label="c1"/>
    <property default="0.000" type="float" value="0.100" name="k2" label="k2"/>
    <property default="color(0.000,0.000,0.000)" type="color" value="color(1.000,0.333,0.000)" name="c2" label="c2"/>
    <property default="0.000" type="float" value="0.300" name="k3" label="k3"/>
    <property default="color(0.000,0.000,0.000)" type="color" value="color(1.000,1.000,0.498)" name="c3" label="c3"/>
    <property default="0.000" type="float" value="0.500" name="k4" label="k4"/>
    <property default="color(0.000,0.000,0.000)" type="color" value="color(0.667,1.000,0.000)" name="c4" label="c4"/>
    <property default="0.000" type="float" value="0.800" name="k5" label="k5"/>
    <property default="color(0.000,0.000,0.000)" type="color" value="color(0.000,0.667,0.000)" name="c5" label="c5"/>
    <property default="1.000" type="float" value="1.000" name="k6" label="k6"/>
    <property default="color(1.000,1.000,1.000)" type="color" value="color(0.333,0.000,1.000)" name="c6" label="c6"/>
    <property default="1.000" type="float" value="1.000" name="k7" label="k7"/>
    <property default="color(1.000,1.000,1.000)" type="color" value="color(0.333,0.000,1.000)" name="c7" label="c7"/>
   </input>
   <output>
    <property default="color(0.000,0.000,0.000)" type="color" value="color(0.000,0.000,0.000)" name="out" label="out"/>
   </output>
   <internal>
    <variable name="k"/>
   </internal>
   <include/>
   <code><![CDATA[	
	  float $(k);
	  
  	$(k) = float spline( $(knotsBasisFunction), clamp( $(pattern), 0, 1), 
  			$(k0), $(k1), $(k2), $(k3), $(k4), $(k5),
  			$(k6), $(k7) );
  	    
    $(out) = color spline( $(colorsBasisFunction), $(k), 
  			$(c0), $(c1), $(c2), $(c3), $(c4), $(c5), 
  			$(c6), $(c7) );
  ]]></code>
   <offset x="-336" y="-418"/>
  </node>
  <node icon="" type="" author="mesh" id="20" name="Wipe" label="Wipe">
   <help></help>
   <input>
    <property default="1.000" type="float" value="1.000" name="input" label="input"/>
    <property default="S" range="S:T" subtype="selector" type="string" value="S" name="direction" label="direction"/>
    <property default="0.000" type="float" value="0.000" name="tspace" label="tspace"/>
    <property default="1.000" type="float" value="1.000" name="bspace" label="bspace"/>
    <property default="1.000" subtype="switch" type="float" value="0.000" name="invert" label="invert">
     <help>Performs an inversion of the results as defined by 1 - result. 
			Behavior will vary with the setting of the Abs and Clamp parameters.
		</help>
    </property>
    <property default="point(0.000,0.000,0.000)" type="point" value="point(0.000,0.000,0.000)" name="Q" label="Q"/>
    <property default="vector(0.000,0.000,0.000)" type="vector" value="vector(0.000,0.000,0.000)" name="dQu" label="dQu"/>
    <property default="vector(0.000,0.000,0.000)" type="vector" value="vector(0.000,0.000,0.000)" name="dQv" label="dQv"/>
   </input>
   <output>
    <property default="0.000" type="float" value="0.000" name="result" label="result"/>
   </output>
   <internal>
    <variable name="x"/>
    <variable name="y"/>
    <variable name="magnitude"/>
    <variable name="dampzone"/>
   </internal>
   <include/>
   <code><![CDATA[

  float $(x) = xcomp( $(Q) ); 
  float $(y) = ycomp( $(Q) ); 
  
  if ( $(direction) == "T" ) 
  {
    $(x) = ycomp( $(Q) ); 
    $(y) = xcomp( $(Q) ); 
  } 
    
  float $(magnitude) = $(input);
  float $(dampzone) = $(bspace) - $(tspace); 
  
  if ( $(y) > $(tspace) ) 
  { 
    if ( $(y) < ( $(tspace) + $(dampzone) ) )  
      $(magnitude) *= ( $(y) - $(tspace) ) / $(dampzone) ; 
  } 
  else
    $(magnitude) = 0;
  
  $(result) = $(magnitude); 
    
  if( $(invert) ) 
    $(result) = 1 - $(result);
             
	
]]></code>
   <offset x="-493" y="-267"/>
  </node>
  <node icon="" type="" author="Pixar" id="21" name="ST" label="ST">
   <help>Returns the 2D surface point based on the underlying\n
	    	ST parameterization of your object.</help>
   <input>
    <property detail="uniform" default="0.000" range="0 360 1" subtype="slider" type="float" value="0.000" name="angle" label="angle">
     <help></help>
    </property>
    <property detail="uniform" default="1.000" type="float" value="1.000" name="repeatS" label="repeatS">
     <help></help>
    </property>
    <property detail="uniform" default="1.000" type="float" value="1.000" name="repeatT" label="repeatT">
     <help></help>
    </property>
    <property detail="uniform" default="0.000" type="float" value="0.000" name="offsetS" label="offsetS">
     <help></help>
    </property>
    <property detail="uniform" default="0.000" type="float" value="0.000" name="offsetT" label="offsetT">
     <help></help>
    </property>
    <property detail="uniform" default="0.000" subtype="switch" type="float" value="0.000" name="flipS" label="flipS">
     <help></help>
    </property>
    <property detail="uniform" default="0.000" subtype="switch" type="float" value="0.000" name="flipT" label="flipT">
     <help></help>
    </property>
   </input>
   <output>
    <property default="point(0.000,0.000,0.000)" type="point" value="point(0.000,0.000,0.000)" name="Q" label="Q"/>
    <property default="vector(0.000,0.000,0.000)" type="vector" value="vector(0.000,0.000,0.000)" name="duQ" label="duQ"/>
    <property default="vector(0.000,0.000,0.000)" type="vector" value="vector(0.000,0.000,0.000)" name="dvQ" label="dvQ"/>
   </output>
   <internal/>
   <include/>
   <code><![CDATA[
		setxcomp( $(Q), $(repeatS) * s + $(offsetS));
    setycomp( $(Q), $(repeatT) * t + $(offsetT));
    setzcomp( $(Q), 0);
    
    if ( $(angle) != 0 )
      $(Q) = rotate($(Q), radians($(angle)), point(0,0,0), point(0,0,1)); 

    $(duQ) = vector Du( $(Q) ) * du;
    $(dvQ) = vector Dv( $(Q) ) * dv;
    
    if ( $(flipS) == 1 )
      setxcomp( $(Q), 1 - xcomp($(Q)) );
    if ( $(flipT) == 1 )
      setycomp( $(Q), 1 - ycomp($(Q)) );
  ]]></code>
   <offset x="-746" y="-169"/>
  </node>
  <node icon="" type="" author="mesh" id="22" name="Depthcue" label="Depthcue">
   <help></help>
   <input>
    <property default="1.000" subtype="switch" type="float" value="1.000" name="exponent" label="exponent"/>
    <property default="0.010" type="float" value="1.500" name="mindepth" label="mindepth"/>
    <property default="1000.000" type="float" value="2.500" name="maxdepth" label="maxdepth"/>
    <property default="1.000" subtype="switch" type="float" value="1.000" name="invert" label="invert">
     <help>Performs an inversion of the results as defined by 1 - result. 
			Behavior will vary with the setting of the Abs and Clamp parameters.
		</help>
    </property>
   </input>
   <output>
    <property default="0.000" type="float" value="0.000" name="result" label="result"/>
   </output>
   <internal>
    <variable name="z"/>
    <variable name="cP"/>
   </internal>
   <include/>
   <code><![CDATA[
	float $(z);
	
  point $(cP);
  $(cP) = transform("camera",P);
  
  if ( $(exponent) ) {
    $(z) = 1 - exp( ( $(mindepth) - zcomp($(cP)) )/($(maxdepth) - $(mindepth) ) );  
  } else {
    $(z) = ( zcomp( $(cP) ) - $(mindepth) )/( $(maxdepth) - $(mindepth) );
  }
    
  if ($(z) > 1) $(z) = 1;
  if ($(z) < 0) $(z) = 0;
  $(result) = 1 - $(z);
  if( $(invert) ) 
        $(result) = 1 - $(result);
  ]]></code>
   <offset x="-492" y="-414"/>
  </node>
  <node icon="" type="" author="Sler guys" id="33" name="voronoi2d" label="voronoi2d">
   <help>Standard voronoi 2D.</help>
   <input>
    <property default="20.000" type="float" value="20.000" name="freq" label="freq"/>
    <property default="1.000" type="float" value="1.000" name="jitter" label="jitter"/>
    <property default="0.000" type="float" value="0.000" name="s" label="s"/>
    <property default="0.000" type="float" value="0.000" name="t" label="t"/>
   </input>
   <output>
    <property default="0.000" type="float" value="0.000" name="f1" label="f1"/>
    <property default="0.000" type="float" value="0.000" name="pos_s" label="pos_s"/>
    <property default="0.000" type="float" value="0.000" name="pos_t" label="pos_t"/>
   </output>
   <internal>
    <variable name="P"/>
    <variable name="thiscell"/>
    <variable name="i"/>
    <variable name="j"/>
    <variable name="testcell"/>
    <variable name="pos"/>
    <variable name="offset"/>
    <variable name="dist"/>
   </internal>
   <include/>
   <code><![CDATA[
point $(P) = point($(s)*$(freq), $(t)*$(freq), 0);
point $(thiscell) = point(floor($(s)*$(freq))+0.5, floor($(t)*$(freq))+0.5, 0);

$(f1) = $(freq)+1;
uniform float $(i), $(j);
for ($(i)=-1; $(i)<=1; $(i)+=1)
{
    for ($(j)=-1; $(j)<=1; $(j)+=1)
    {
        point $(testcell) = $(thiscell) + vector($(i), $(j), 0);
        point $(pos) = $(testcell) + $(jitter)*(vector cellnoise($(testcell)) - 0.5);
        vector $(offset) = $(pos) - $(P);
        float $(dist) = $(offset).$(offset);

        if ($(dist) < $(f1))
        {
            $(f1) = $(dist);
            $(pos_s) = xcomp($(pos));
            $(pos_t) = ycomp($(pos));      
        }
    }
}

$(pos_s) /= $(freq);
$(pos_t) /= $(freq);

$(f1) = sqrt($(f1));
]]></code>
   <offset x="-809" y="284"/>
  </node>
  <node icon="" type="variable" author="Libero Spagnolini" id="34" name="s" label="s">
   <help>Renderer texture coordinate s.</help>
   <input/>
   <output>
    <property default="0.000" type="float" value="0.000" name="s" label="s"/>
   </output>
   <internal/>
   <include/>
   <code><![CDATA[
	  $(s) = s;
	  ]]></code>
   <offset x="-955" y="223"/>
  </node>
  <node icon="" type="variable" author="Libero Spagnolini" id="35" name="t" label="t">
   <help>Renderer texture coordinate t.</help>
   <input/>
   <output>
    <property default="0.000" type="float" value="0.000" name="t" label="t"/>
   </output>
   <internal/>
   <include/>
   <code><![CDATA[
	  $(t) = t;
	  ]]></code>
   <offset x="-954" y="286"/>
  </node>
  <node icon="" type="" author="mesh" id="36" name="Circle" label="Circle">
   <help>Generator of circle shape</help>
   <input>
    <property detail="uniform" default="0.000" range="Solid:Lineriar:Hemisphere" subtype="selector" type="float" value="0.000" name="FillType" label="Fill Type"/>
    <property default="0.300" range="0.01 0.5 .01" subtype="slider" type="float" value="0.300" name="Radius" label="Radius"/>
    <property detail="uniform" default="triangle" range="box:triangle:catmull-rom:gaussian" subtype="selector" type="string" value="triangle" name="Filter" label="Filter"/>
    <property detail="uniform" default="1.000" range="0 32 .1" subtype="slider" type="float" value="1.000" name="fwidth" label="Filter width"/>
    <property default="0.000" range="0 1 .01" subtype="slider" type="float" value="0.000" name="Fuzziness" label="Fuzziness"/>
    <property detail="uniform" default="0.000" subtype="switch" type="float" value="0.000" name="Invert" label="Invert"/>
    <property default="point(0.000,0.000,0.000)" type="point" value="point(0.000,0.000,0.000)" name="Q" label="Q"/>
    <property default="vector(0.000,0.000,0.000)" type="vector" value="vector(0.000,0.000,0.000)" name="duQ" label="duQ"/>
    <property default="vector(0.000,0.000,0.000)" type="vector" value="vector(0.000,0.000,0.000)" name="dvQ" label="dvQ"/>
   </input>
   <output>
    <property default="0.000" type="float" value="0.000" name="result" label="result"/>
   </output>
   <internal>
    <variable name="x"/>
    <variable name="y"/>
    <variable name="r"/>
    <variable name="dr"/>
    <variable name="rr"/>
   </internal>
   <include/>
   <code><![CDATA[
	float	$(x) = xcomp( $(Q) )-.5;
	float $(y) = ycomp( $(Q) )-.5;
	
	float	$(r) = sqrt ( $(x) * $(x) + $(y) * $(y) );
	
	$(x) = xcomp ( $(duQ) ) + xcomp ( $(dvQ) );
	$(y) = ycomp ( $(duQ) ) + ycomp ( $(dvQ) );
	
	float $(dr) = max ( .5 * $(Fuzziness), sqrt ( $(x) * $(x) + $(y) * $(y) ) );

	/* Solid */
	$(result) = 1 - filterstep ( $(Radius), $(r), $(r) + $(dr), "filter", $(Filter), "width", $(fwidth) );	
	
	if ( $(FillType) == 1.0 ) {	/* lineriar */
		$(result) = $(result) * ( ( $(Radius) - $(r) ) / $(Radius) );
	} else 
	  if ( $(FillType) == 2.0 ) {	/* Hemisphere  */
		float $(rr) = ( PI/2 ) * ( ( $(Radius) - $(r) ) / $(Radius) );
		$(result) *=  sin ( $(rr) ) ;
	}
	      		
	if( $(Invert) != 0 )
		$(result) = 1 - $(result);
  ]]></code>
   <offset x="-470" y="-71"/>
  </node>
  <node icon="" type="" author="Simon Bunker" id="46" name="xray" label="xray">
   <help>Simple xray surface shader; assign it to Oi.</help>
   <input>
    <property default="1.000" type="float" value="1.000" name="edgefalloff" label="edgefalloff"/>
   </input>
   <output>
    <property default="color(0.000,0.000,0.000)" type="color" value="color(0.000,0.000,0.000)" name="outOpacity" label="outOpacity"/>
   </output>
   <internal>
    <variable name="opac"/>
   </internal>
   <include/>
   <code><![CDATA[
float $(opac) = pow ( abs(normalize(N).normalize(I)), $(edgefalloff) );
$(outOpacity)= ( 1 - $(opac) ) * Oi;
]]></code>
   <offset x="87" y="134"/>
  </node>
  <node icon="" type="rsl_code" author="Ivan DeWolf" id="47" name="IDbubbly" label="IDbubbly">
   <help>bubbly.sl written a while ago by Ivan DeWolf ivan@martian-tools.com
    		basicly it is F1 squared as described in a cellular texture basis function
    		by Steven Worley in the siggraph proceedings from 1996, except this uses a noised grid of cells
    		instead of the sparse convolution in the paper. not as elegant, but hey, it works.
    		the bubbles are paraboloids diplaced along the normal. </help>
   <input>
    <property default="point(0.000,0.000,0.000)" type="point" value="point(0.000,0.000,0.000)" name="P" label="P"/>
    <property default="normal(0.000,1.000,0.000)" type="normal" value="normal(0.000,1.000,0.000)" name="N" label="N"/>
    <property default="0.200" type="float" value="0.200" name="Kd" label="Kd"/>
    <property default="5.000" type="float" value="5.000" name="mult" label="mult"/>
    <property default="1.000" type="float" value="1.000" name="Nzscale" label="Nzscale"/>
    <property default="1.000" type="float" value="1.000" name="bubsize" label="bubsize"/>
   </input>
   <output>
    <property default="point(0.000,0.000,0.000)" type="point" value="point(0.000,0.000,0.000)" name="outP" label="outP"/>
    <property default="normal(0.000,0.000,0.000)" type="normal" value="normal(0.000,0.000,0.000)" name="outN" label="outN"/>
   </output>
   <internal>
    <variable name="Nn"/>
    <variable name="a"/>
    <variable name="b"/>
    <variable name="c"/>
    <variable name="bub"/>
    <variable name="dist"/>
    <variable name="shortest"/>
    <variable name="Po"/>
    <variable name="trucell"/>
    <variable name="surrcell"/>
    <variable name="nzcell"/>
    <variable name="offset"/>
   </internal>
   <include/>
   <code><![CDATA[
	  normal $(Nn) = normalize($(N));
    float $(a), $(b), $(c), $(bub);
    float $(dist), $(shortest)=10000;
    
    point $(Po) = transform( "object", $(P) ) * $(mult);
  
    /* true cell center, surrounding cell centers, noised cell center */
    point $(trucell), $(surrcell), $(nzcell);
    vector $(offset);
    
    setxcomp ( $(trucell), floor ( xcomp ( $(Po) ) ) + .5 );
    setycomp ( $(trucell) ,floor ( ycomp ( $(Po) ) ) + .5 );
    setzcomp ( $(trucell), floor ( zcomp ( $(Po) ) ) + .5 );
  			     
    /* what is the shortest distance to a noised cell center? */
    for ( $(a) = -1 ; $(a) <= 1 ; $(a) += 1 ) 
    {
      for ( $(b) = -1 ; $(b) <= 1 ; $(b) += 1 )
      {
        for ( $(c) = -1 ; $(c) <= 1 ; $(c) += 1 )
        {
        	$(offset) = vector ( $(a), $(b), $(c) );
        	$(surrcell) = $(trucell) + $(offset);
        	$(nzcell) = $(surrcell) + ( ( vector cellnoise ( $(surrcell) ) - .5) * $(Nzscale) );
        	$(dist) = distance ( $(Po), $(nzcell) );
        	if ( $(dist) < $(shortest) ) 
        	  $(shortest) = $(dist);
        }
      }
    }
    $(bub) = clamp ( $(shortest), 0, $(bubsize) ) / $(bubsize); 
    $(P) += $(Nn) * ( pow ( $(bub), 2 ) - 1 ) * $(Kd);
    $(N) = calculatenormal ( $(P) );
          
	  $(outP) = $(P); 
	  $(outN) = $(N);
	  ]]></code>
   <offset x="-319" y="-632"/>
  </node>
  <node icon="" type="variable" author="mesh" id="48" name="P" label="P">
   <help>Global point P.</help>
   <input/>
   <output>
    <property default="point(0.000,0.000,0.000)" type="point" value="point(0.000,0.000,0.000)" name="P" label="P"/>
   </output>
   <internal/>
   <include/>
   <code><![CDATA[
	  #ifdef SURFACE_SHADER
	  $(P) = P;
	  #endif
	  #ifdef DISPLACEMENT_SHADER
	  $(P) = P;
	  #endif
	  #ifdef LIGHT_SHADER
	  $(P) = Ps;
	  #endif
	  #ifdef VOLUME_SHADER
	  $(P) = Pv;
	  #endif
	  ]]></code>
   <offset x="-474" y="-623"/>
  </node>
  <node icon="" type="variable" author="mesh" id="49" name="N" label="N">
   <help>Global normal N.</help>
   <input/>
   <output>
    <property default="normal(0.000,0.000,0.000)" type="normal" value="normal(0.000,0.000,0.000)" name="N" label="N"/>
   </output>
   <internal/>
   <include/>
   <code><![CDATA[
	#ifdef SURFACE_SHADER
	  $(N) = N;
	  #endif
	  #ifdef DISPLACEMENT_SHADER
	  $(N) = N;
	  #endif
	  #ifdef LIGHT_SHADER
	  $(N) = Ns;
	  #endif
	  #ifdef VOLUME_SHADER
	  $(N) = Nv;
	  #endif
	]]></code>
   <offset x="-473" y="-562"/>
  </node>
  <node icon="" type="displacement" author="mesh" id="50" name="displace" label="displace">
   <help>Root displacement shader.</help>
   <input>
    <property default="point(0.000,0.000,0.000)" type="point" value="point(0.000,0.000,0.000)" name="P" label="P"/>
    <property default="normal(0.000,1.000,0.000)" type="normal" value="normal(0.000,1.000,0.000)" name="N" label="N"/>
   </input>
   <output>
    <property default="${NODELABEL}" type="displacement" value="${NODELABEL}" name="disp" label="disp"/>
   </output>
   <internal/>
   <include/>
   <code><![CDATA[
	  P = $(P); 
	  N = $(N);
	]]></code>
   <offset x="-155" y="-295"/>
  </node>
  <node icon="" type="" author="mesh" id="52" name="FaceforwardNormal" label="FaceforwardNormal">
   <help>Faceforward Normalized Normal.</help>
   <input/>
   <output>
    <property default="normal(0.000,0.000,0.000)" type="normal" value="normal(0.000,0.000,0.000)" name="Nf" label="Nf"/>
   </output>
   <internal/>
   <include/>
   <code><![CDATA[
	$(Nf) = faceforward( normalize(N), I );
	]]></code>
   <offset x="-582" y="211"/>
  </node>
  <node icon="" type="" author="mesh" id="54" name="clampC" label="clampC">
   <help>
	clamp(input,min,max) returns "min:  if "input" is less than "min", "max" if a is greater than "max"; 
	otherwise it returns "input"
	</help>
   <input>
    <property default="color(0.000,0.000,0.000)" type="color" value="color(0.000,0.000,0.000)" name="input" label="input"/>
    <property default="color(0.000,0.000,0.000)" type="color" value="color(0.000,0.000,0.000)" name="min" label="min"/>
    <property default="color(1.000,1.000,1.000)" type="color" value="color(1.000,1.000,1.000)" name="max" label="max"/>
   </input>
   <output>
    <property default="color(0.000,0.000,0.000)" type="color" value="color(0.000,0.000,0.000)" name="result" label="result"/>
   </output>
   <internal/>
   <include/>
   <code><![CDATA[
 $(result) = clamp(($(input)), ($(min)), ($(max)));
]]></code>
   <offset x="-151" y="135"/>
  </node>
  <node icon="me_CookTorrance.png" type="" author="mesh" id="55" name="me_CookTorrance" label="me_CookTorrance">
   <help>Specular function (Cook-Torrance BRDF) based on code from Brent Watkins Advanced Digital Cinematography HW6</help>
   <input>
    <property default="normal(0.000,0.000,0.000)" type="normal" value="normal(0.000,0.000,0.000)" name="Nf" label="Nf"/>
    <property default="" type="string" value="" name="category" label="category"/>
    <property default="color(1.000,1.000,1.000)" type="color" value="color(1.000,1.000,1.000)" name="Coloration" label="Coloration"/>
    <property default="0.150" range="0 1 0.001" subtype="slider" type="float" value="0.150" name="Ks" label="Ks"/>
    <property default="0.300" range="0 2 0.001" subtype="slider" type="float" value="0.300" name="IndexOfRefraction" label="IndexOfRefraction">
     <help>Index of refraction for the surface</help>
    </property>
    <property default="0.100" range="0 1 0.001" subtype="slider" type="float" value="0.143" name="m" label="m">
     <help>Root-mean-square slope of surface microfacets</help>
    </property>
   </input>
   <output>
    <property default="color(0.000,0.000,0.000)" type="color" value="color(0.000,0.000,0.000)" name="result" label="result"/>
   </output>
   <internal>
    <variable name="V"/>
    <variable name="cook"/>
    <variable name="vdotn"/>
    <variable name="distro"/>
    <variable name="geom"/>
    <variable name="fresnel_hack"/>
   </internal>
   <include/>
   <code><![CDATA[
  /* microfacet distribution function */
	  float $(distro) ( normal Nn;
		        vector H;
			float m; )
	  {
	    float ndoth = Nn.H;
	    float beta = acos( ndoth );
	    float tanbeta = tan( beta );
	    float tanbeta_over_m = tanbeta/m;
	    float D = exp(-(tanbeta_over_m*tanbeta_over_m));
	    D /= 4*m*m*pow(ndoth,4);
	    return D;
	  }
	/* geometric attenuation factor */
	  float $(geom) ( normal Nn;
		      vector H;
		      vector L;
		      vector V )
	  {
	    float ndoth = Nn.H;
	    float ndotv = Nn.V;
	    float ndotl = Nn.L;
	    float vdoth = V.H;

	    float masking = 2*ndoth*ndotv/vdoth;
	    float shadowing = 2*ndoth*ndotl/vdoth;
	    return min(1,min(masking,shadowing));
	  }

	  /* fresnel conductance term - using the faster approximation */
    float $(fresnel_hack) ( normal Nn;
			      normal V;
			      float n; )
	  {
	    float ndotv = N.V;

	    float foo = pow(1-ndotv, 5);
	    return 1-foo + n*foo;
	  }
	  
	  vector $(V) = -normalize(I);

	  float $(cook) = 0;
	  illuminance( $(category), P, $(Nf), PI/2 )
	  {
	    vector Ln = normalize(L);
	    vector H = normalize( Ln + $(V) );
	    float D = $(distro) ( $(Nf), H, $(m) );
	    float G = $(geom) ( $(Nf), H, Ln, $(V) );
	    float F = $(fresnel_hack) ( $(Nf), $(V), $(IndexOfRefraction) );

	    $(cook) += D*G*F;
	  }
	  float $(vdotn) = $(V).$(Nf);
	  $(cook) /= $(vdotn);
	  /* normalize - preserves conservation of energy */
	  $(cook) /= PI;

	  $(result) = $(Coloration) * $(Ks) * $(cook);
  ]]></code>
   <offset x="-334" y="26"/>
  </node>
  <node icon="" type="" author="Konstantin Kharitonov" id="56" name="normalizeI" label="normalizeI">
   <help>Returns normalize(I).</help>
   <input/>
   <output>
    <property default="vector(0.000,0.000,0.000)" type="vector" value="vector(0.000,0.000,0.000)" name="In" label="In"/>
   </output>
   <internal/>
   <include/>
   <code><![CDATA[
	  $(In) = normalize(I);
	  ]]></code>
   <offset x="-750" y="479"/>
  </node>
  <node icon="" type="" author="Konstantin Kharitonov" id="57" name="normalizeN" label="normalizeN">
   <help>Returns normalize(N).</help>
   <input/>
   <output>
    <property default="normal(0.000,0.000,0.000)" type="normal" value="normal(0.000,0.000,0.000)" name="Nn" label="Nn"/>
   </output>
   <internal/>
   <include/>
   <code><![CDATA[
	  $(Nn) = normalize(N);
	  ]]></code>
   <offset x="-568" y="338"/>
  </node>
  <node icon="me_CookTorrance.png" type="" author="Scott Eaton" id="58" name="me_CookTorrance2" label="me_CookTorrance2">
   <help>A simple implementation of the Cook-Torrance shading model describe in:  
  A Reflectance Model for Computer Graphics R. L. Cook, K. E. Torrance, ACM Transactions on Graphics 1982</help>
   <input>
    <property default="normal(0.000,0.000,0.000)" type="normal" value="normal(0.000,0.000,0.000)" name="Nn" label="Nn"/>
    <property default="" type="string" value="" name="category" label="category"/>
    <property default="color(1.000,1.000,1.000)" type="color" value="color(1.000,1.000,1.000)" name="Coloration" label="Coloration"/>
    <property default="0.150" range="0 1 0.001" subtype="slider" type="float" value="0.150" name="Ks" label="Ks"/>
    <property default="1.300" range="0 2 0.001" subtype="slider" type="float" value="0.097" name="IOR" label="IndexOfRefraction">
     <help>Index of refraction for the surface</help>
    </property>
    <property default="0.200" range="0 1 0.001" subtype="slider" type="float" value="0.256" name="roughness" label="roughness">
     <help>Root-mean-square slope of surface microfacets</help>
    </property>
    <property default="100.000" type="float" value="100.000" name="gaussConstant" label="gaussConstant"/>
   </input>
   <output>
    <property default="color(0.000,0.000,0.000)" type="color" value="color(0.000,0.000,0.000)" name="result" label="result"/>
   </output>
   <internal>
    <variable name="Vn"/>
    <variable name="cook"/>
    <variable name="F"/>
    <variable name="Ktransmit"/>
    <variable name="m"/>
    <variable name="NdotV"/>
   </internal>
   <include/>
   <code><![CDATA[
  vector $(Vn) = normalize(-I);
  float $(F), $(Ktransmit);
  float $(m) = $(roughness);
  fresnel( normalize(I), $(Nn), 1/$(IOR), $(F), $(Ktransmit) );
  
  color $(cook) = 0;
  float $(NdotV) = $(Nn).$(Vn);
  
  illuminance( $(category), P, $(Nn), PI/2 )
  {
    /* half angle vector */
    vector Ln = normalize( L );
    vector H = normalize( $(Vn) + Ln );
    
    float NdotH = $(Nn).H;
    float NdotL = $(Nn).Ln;
    float VdotH = $(Vn).H;
    
    float D;
    float alpha = acos( NdotH );
    
    /* microfacet distribution */
    D = $(gaussConstant) * exp( -( alpha*alpha )/( $(m)*$(m) ) );
    
    /* geometric attenuation factor */
    float G = min( 1, min( ( 2*NdotH*$(NdotV) / VdotH ), ( 2*NdotH*NdotL / VdotH ) ) );
    
    /* sum contributions */
    $(cook) += Cl * ($(F)*D*G) / ( PI*$(NdotV) );
  }
  $(result) = $(Coloration) * $(Ks) * $(cook) / PI;
  ]]></code>
   <offset x="-369" y="222"/>
  </node>
 </nodes>
 <links>
  <link srcNode_id="1" dstNode_id="2" id="3" srcParam="ImageFile" dstParam="image"/>
  <link srcNode_id="54" dstNode_id="4" id="8" srcParam="result" dstParam="Ci"/>
  <link srcNode_id="52" dstNode_id="55" id="12" srcParam="Nf" dstParam="Nf"/>
  <link srcNode_id="3" dstNode_id="1" id="13" srcParam="rib" dstParam="Globals"/>
  <link srcNode_id="58" dstNode_id="54" id="15" srcParam="result" dstParam="input"/>
  <link srcNode_id="52" dstNode_id="58" id="17" srcParam="Nf" dstParam="Nn"/>
  <link srcNode_id="21" dstNode_id="20" id="37" srcParam="Q" dstParam="Q"/>
  <link srcNode_id="21" dstNode_id="20" id="38" srcParam="duQ" dstParam="dQu"/>
  <link srcNode_id="21" dstNode_id="20" id="39" srcParam="dvQ" dstParam="dQv"/>
  <link srcNode_id="20" dstNode_id="19" id="40" srcParam="result" dstParam="pattern"/>
  <link srcNode_id="34" dstNode_id="33" id="76" srcParam="s" dstParam="s"/>
  <link srcNode_id="35" dstNode_id="33" id="77" srcParam="t" dstParam="t"/>
  <link srcNode_id="21" dstNode_id="36" id="79" srcParam="Q" dstParam="Q"/>
  <link srcNode_id="21" dstNode_id="36" id="80" srcParam="duQ" dstParam="duQ"/>
  <link srcNode_id="21" dstNode_id="36" id="81" srcParam="dvQ" dstParam="dvQ"/>
  <link srcNode_id="49" dstNode_id="47" id="100" srcParam="N" dstParam="N"/>
  <link srcNode_id="48" dstNode_id="47" id="101" srcParam="P" dstParam="P"/>
  <link srcNode_id="47" dstNode_id="50" id="102" srcParam="outP" dstParam="P"/>
  <link srcNode_id="47" dstNode_id="50" id="103" srcParam="outN" dstParam="N"/>
  <link srcNode_id="4" dstNode_id="1" id="105" srcParam="surface" dstParam="FG_surf"/>
 </links>
</nodenet>
