/* Generated by meShaderEd */

#define SURFACE_SHADER surface_aov
surface surface_aov (
output varying color __sss = color(0.000,0.000,0.000);
output varying color __pstrace = color(0.000,0.000,0.000);
output varying color __spec = color(0.000,0.000,0.000);
output varying color __reflect = color(0.000,0.000,0.000);
output varying color __spec_ibi = color(0.000,0.000,0.000);
output varying color __diff = color(0.000,0.000,0.000);
output varying color __occ_C = color(0.000,0.000,0.000);
output varying color __diff_ibi = color(0.000,0.000,0.000);
output varying float __mask = 1.000;
output varying color __color = color(0.000,0.000,0.000);
output varying color __shadow = color(0.000,0.000,0.000);
output varying color __mask_C = color(1.000,0.000,0.000);
output varying float __occ = 0.000;
)
{
point P_P = point(0.000,0.000,0.000);
float FractalC_Layers = 6.000;
float FractalC_Frequency = 1.000;
float FractalC_Lacunarity = 2.000;
float FractalC_Dimension = 1.000;
float FractalC_Erosion = 0.000;
float FractalC_Measure = 0.000;
float FractalC_Variation = 0.000;
vector FractalC_duQ = vector(0.000,0.000,0.000);
vector FractalC_dvQ = vector(0.000,0.000,0.000);
color FractalC_result = color(0.000,0.000,0.000);
float blinn_diffuseCoeff = 0.800;
color blinn_ambientColor = color(0.000,0.000,0.000);
color blinn_incandescence = color(0.000,0.000,0.000);
float blinn_translucence = 0.000;
color blinn_specularColor = color(0.500,0.500,0.500);
float blinn_eccentricity = 0.300;
float blinn_specularRollOff = 0.700;
color blinn_outColor = color(1.000,1.000,1.000);
color surface_aov_Oi = color(1.000,1.000,1.000);
float surface_aov_Premultiply = 1.000;
color surface_aov_diff = color(0.000,0.000,0.000);
color surface_aov_spec = color(0.000,0.000,0.000);
color surface_aov_diff_ibi = color(0.000,0.000,0.000);
color surface_aov_spec_ibi = color(0.000,0.000,0.000);
color surface_aov_shadow = color(0.000,0.000,0.000);
color surface_aov_reflect = color(0.000,0.000,0.000);
color surface_aov_sss = color(0.000,0.000,0.000);
color surface_aov_pstrace = color(0.000,0.000,0.000);
float surface_aov_occ = 0.000;
color surface_aov_occ_C = color(0.000,0.000,0.000);
float surface_aov_mask = 1.000;
color surface_aov_mask_C = color(1.000,0.000,0.000);
color surface_aov_extra_C = color(1.000,0.000,0.000);
float surface_aov_extra_F = 1.000;

	  #ifdef SURFACE_SHADER
	  P_P = P;
	  #endif
	  #ifdef DISPLACEMENT_SHADER
	  P_P = P;
	  #endif
	  #ifdef LIGHT_SHADER
	  P_P = Ps;
	  #endif
	  #ifdef VOLUME_SHADER
	  P_P = Pv;
	  #endif
	  	
	  color FractalC_Noise(point Q)
		{
			extern float FractalC_Variation;
			color	C;
			
			C = color noise( Q, FractalC_Variation );
			C = color( 
			    smoothstep(.2, .8, comp(C, 0)),
			    smoothstep(.2, .8, comp(C, 1)),
			    smoothstep(.2, .8, comp(C, 2))
			);
			return (C);
		}
		    
		float FractalC_Distance(float type; color C)
		{
			float	result;
			if (type == 1)	/* Saturation */
			  result = comp (ctransform ("RGB", "HSY", C), 1);
			else if (type == 2)	/* Luminance */
			  result = comp (ctransform ("RGB", "HSY", C), 2);
			else	/* Gray */
			  result = length (vector (C - color .5)) + .319;
						return (result);
		}
		uniform float	FractalC_i;
		float	FractalC_sum, FractalC_mag, FractalC_f, FractalC_offset;
		float	FractalC_dQ;
		    
		FractalC_dQ = max(
			max( abs(xcomp( FractalC_duQ )) + abs(xcomp( FractalC_dvQ )), abs(ycomp( FractalC_duQ )) + abs(ycomp( FractalC_dvQ )) ),
			abs(zcomp( FractalC_duQ )) + abs(zcomp( FractalC_dvQ ))
		);

		FractalC_f = FractalC_Frequency;
		FractalC_result = mix( FractalC_Noise( FractalC_f * P_P ), color .5, smoothstep (.25, 1, FractalC_f * FractalC_dQ ));
		FractalC_sum = 1;

		for ( FractalC_i = 1 ; FractalC_i < FractalC_Layers ; FractalC_i += 1) 
	  {
			FractalC_f *= FractalC_Lacunarity;
			FractalC_offset = mix(-FractalC_Erosion, FractalC_Erosion, FractalC_Distance( FractalC_Measure, FractalC_result/FractalC_sum ) );
			FractalC_mag = 1/pow( FractalC_f, 3 - 2 * FractalC_Dimension + FractalC_offset );
			FractalC_result += FractalC_mag * mix( FractalC_Noise( FractalC_f * P_P ), color .5, smoothstep (.25, 1, FractalC_f * FractalC_dQ ));
			FractalC_sum += FractalC_mag;
		}

		FractalC_result /= FractalC_sum;	
   
 normal blinn_Nf;
 vector blinn_H, blinn_Ln, blinn_V;
 color blinn_Ia, blinn_Id, blinn_Itr, blinn_Is;
 float blinn_NH, blinn_NH2, blinn_NHSQ, blinn_Dd, blinn_Gg, blinn_VN, blinn_VH, blinn_LN, blinn_Ff, blinn_tmp;
 float blinn_E= 1 / (blinn_eccentricity * blinn_eccentricity- 1);
  
 blinn_Nf= faceforward(normalize(N), I);
 blinn_Ia= ambient() + blinn_ambientColor;
 blinn_Id= blinn_diffuseCoeff* diffuse(blinn_Nf);
 
 blinn_Itr= 0;
 if (blinn_translucence!= 0) {
  illuminance(P, blinn_Nf, PI)
  blinn_Itr+= Cl;
  blinn_Itr*= blinn_translucence;
 }
 
 blinn_Is= 0;
 blinn_V= normalize(-I);
 blinn_VN= blinn_V.blinn_Nf;
 illuminance(P, blinn_Nf, PI * 0.5) {
  blinn_Ln= normalize(L);
  blinn_H= normalize(blinn_Ln+blinn_V);
  blinn_NH= blinn_Nf.blinn_H;
  blinn_NHSQ= blinn_NH*blinn_NH;
  blinn_NH2= blinn_NH* 2;
  blinn_Dd= (blinn_E+1) / (blinn_NHSQ+ blinn_E);
  blinn_Dd*= blinn_Dd;
  blinn_VH= blinn_V.blinn_H;
  blinn_LN= blinn_Ln.blinn_Nf;
  if (blinn_VN < blinn_LN) {
   if (blinn_VN* blinn_NH2 < blinn_VH)
   blinn_Gg= blinn_NH2/ blinn_VH;
   else
   blinn_Gg= 1 / blinn_VN;
   }
  else {
   if (blinn_LN* blinn_NH2 < blinn_VH)
   blinn_Gg= (blinn_LN* blinn_NH2) / (blinn_VH* blinn_VN);
  else
  blinn_Gg= 1 / blinn_VN;
 }
 blinn_tmp= pow((1 - blinn_VH), 3);
 blinn_Ff= blinn_tmp+ (1 - blinn_tmp) * blinn_specularRollOff;
 blinn_Is+= Cl * blinn_Dd* blinn_Gg* blinn_Ff;
 }
 blinn_Is*= blinn_specularColor;
 
 blinn_outColor= FractalC_result* (blinn_Ia + blinn_Id + blinn_Itr + blinn_incandescence+ blinn_Is);

	Ci = blinn_outColor * surface_aov_Oi; 
	Oi = surface_aov_Oi;
	__color = FractalC_result * surface_aov_Oi;
	__diff = surface_aov_diff * surface_aov_Oi;
	__spec = surface_aov_spec * surface_aov_Oi;
	__diff_ibi = surface_aov_diff_ibi * surface_aov_Oi;
	__spec_ibi = surface_aov_spec_ibi * surface_aov_Oi;
	__shadow = surface_aov_shadow * surface_aov_Oi;
	__reflect = surface_aov_reflect * surface_aov_Oi;
	__sss = surface_aov_sss * surface_aov_Oi;
	
	__pstrace = surface_aov_pstrace * surface_aov_Oi;
	
	__occ = comp ( surface_aov_occ * surface_aov_Oi, 0 );
	__occ_C = surface_aov_occ_C * surface_aov_Oi;
	
	__mask = comp ( surface_aov_mask * surface_aov_Oi, 0 );
	__mask_C = surface_aov_mask_C * surface_aov_Oi;
	
	color surface_aov_dummy_C = surface_aov_extra_C * surface_aov_Oi;
	float surface_aov_dummy_F = comp ( surface_aov_extra_F * surface_aov_Oi, 0 ); 
	
	
}
