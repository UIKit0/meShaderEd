/* Generated by meShaderEd */

#define DISPLACEMENT_SHADER disp
displacement disp (
)
{
normal N_N = normal(0.000,0.000,0.000);
point P_P = point(0.000,0.000,0.000);
string IDgloop_space = "object";
float IDgloop_Kd = 0.200;
float IDgloop_mag = 0.200;
float IDgloop_freq = 5.000;
float IDgloop_numsteps = 20.000;
point IDgloop_outP = point(0.000,0.000,0.000);
normal IDgloop_outN = normal(0.000,0.000,0.000);

	  #ifdef SURFACE_SHADER
	  P_P = P;
	  #endif
	  #ifdef DISPLACEMENT_SHADER
	  P_P = P;
	  #endif
	  #ifdef LIGHT_SHADER
	  P_P = Ps;
	  #endif
	  #ifdef VOLUME_SHADER
	  P_P = Pv;
	  #endif
	  
	#ifdef SURFACE_SHADER
	  N_N = N;
	  #endif
	  #ifdef DISPLACEMENT_SHADER
	  N_N = N;
	  #endif
	  #ifdef LIGHT_SHADER
	  N_N = Ns;
	  #endif
	  #ifdef VOLUME_SHADER
	  N_N = Nv;
	  #endif
	
	  
		vector IDgloop_overdist = 0.1;
		vector IDgloop_stepsize = IDgloop_mag / IDgloop_freq;
		
		string IDgloop_sys = IDgloop_space;
		
		if ( IDgloop_space == "" ) IDgloop_sys = "object";  
		
		point  IDgloop_Psh = transform ( IDgloop_sys, P_P ) * IDgloop_freq;
		vector IDgloop_dPduN = normalize ( vtransform ( IDgloop_sys, dPdu ) );
		vector IDgloop_dPdvN = normalize ( vtransform ( IDgloop_sys, dPdv ) );

		point  IDgloop_Pou = IDgloop_Psh + ( IDgloop_dPduN * IDgloop_overdist );
		point  IDgloop_Pov = IDgloop_Psh + ( IDgloop_dPdvN * IDgloop_overdist );

		float  IDgloop_nz = noise ( IDgloop_Psh ) - 0.5;
		float  IDgloop_nzou = noise ( IDgloop_Pou ) - 0.5;
		float  IDgloop_nzov = noise ( IDgloop_Pov ) - 0.5;

		float  IDgloop_chu = ( IDgloop_nz - IDgloop_nzou );
		float  IDgloop_chv = ( IDgloop_nz - IDgloop_nzov );

		vector IDgloop_DdPdu = IDgloop_dPduN;
		vector IDgloop_DdPdv = IDgloop_dPdvN;

		vector IDgloop_step = IDgloop_DdPdu ^ IDgloop_DdPdv;

		float  IDgloop_i;
		for ( IDgloop_i = 1 ; IDgloop_i < IDgloop_numsteps ; IDgloop_i += 1 )
		{
			P_P -= vtransform ( IDgloop_sys, "current", IDgloop_step ) * IDgloop_nz * IDgloop_stepsize;
			IDgloop_DdPdu = normalize ( IDgloop_DdPdu + ( IDgloop_step * IDgloop_chu ) );
			IDgloop_DdPdv = normalize ( IDgloop_DdPdv + ( IDgloop_step * IDgloop_chv ) );
		  IDgloop_step = IDgloop_DdPdu ^ IDgloop_DdPdv;
		}
		normal IDgloop_Nn = normalize ( N_N );
    P_P += IDgloop_Nn * IDgloop_Kd * (-1); 
    N_N = normalize ( calculatenormal( P_P ) );
         
	  IDgloop_outP = P_P; 
	  IDgloop_outN = N_N;
	  
	  P = IDgloop_outP; 
	  N = IDgloop_outN;
	
}
