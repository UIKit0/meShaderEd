/* Generated by meShaderEd */

#define SURFACE_SHADER metal_ibi
surface metal_ibi (
uniform float occlusion_MaxSamples = 128.000;
uniform float occlusion_MinSamples = 64.000;
uniform float occlusion_MaxDist = 1.000;
uniform float occlusion_Bias = 0.050;
float spec_ibi_rBlur = 0.000;
float spec_ibi_KrMin = 0.430;
float spec_ibi_KrMax = 0.880;
float spec_ibi_IOR = 1.500;
float spec_ibi_sat_value = 0.490;
float blinn_Ks = 1.000;
float blinn_eccentricity = 0.300;
float blinn_specularRollOff = 0.700;
float diff_Kd = 0.490;
float diff_ibi_dBlur = 0.750;
float diff_ibi_Kd = 0.750;
color diff_ibi_add_inColor2 = color(0.400,0.400,0.400);
float diff_ibi_sat_value = 0.380;
float ffwd_Attenuation = 1.000;
color base_color_inColor1 = color(0.745,0.745,0.745);
color base_color_inColor2 = color(0.208,0.208,0.208);
float comp_diff_ibi_mult = 0.480;
float comp_diff_mult = 0.840;
float comp_spec_mult = 1.000;
float comp_spec_ibi_mult = 1.000;
float comp_occ_mult = 0.350;
output varying color __sss = color(0.000,0.000,0.000);
output varying color __pstrace = color(0.000,0.000,0.000);
output varying vector __L = vector(0.000,0.000,1.000);
output varying color __spec = color(0.000,0.000,0.000);
output varying color __reflect = color(0.000,0.000,0.000);
output varying color __spec_ibi = color(0.000,0.000,0.000);
output varying color __diff = color(0.000,0.000,0.000);
output varying color __occ_C = color(0.000,0.000,0.000);
output varying color __diff_ibi = color(0.000,0.000,0.000);
output varying float __mask = 1.000;
output varying color __color = color(0.000,0.000,0.000);
output varying color __shadow = color(0.000,0.000,0.000);
output varying color __mask_C = color(1.000,0.000,0.000);
output varying float __occ = 0.000;
output varying float __blur = 0.000;
)
{
color psTrace_out = color(0.000,0.000,0.000);
normal ShadingNormal_NS = normal(0.000,0.000,0.000);
uniform float occlusion_Invert = 0.000;
uniform float occlusion_Adaptive = 1.000;
uniform vector occlusion_SkyAxis = vector(0.000,1.000,0.000);
float occlusion_ConeAngle = 90.000;
uniform float occlusion_SampleBase = 0.000;
uniform string occlusion_HitMode = "default";
uniform string occlusion_HitSides = "both";
uniform float occlusion_MaxVar = 0.150;
uniform float occlusion_MaxError = -1.000;
uniform float occlusion_MaxPixelDist = 0.000;
uniform string occlusion_Distribution = "cosine";
uniform float occlusion_FalloffMode = 0.000;
uniform float occlusion_FalloffValue = 0.000;
uniform string occlusion_EnvMap = "";
uniform string occlusion_EnvSpace = "";
uniform float occlusion_BrtWarp = 1.000;
uniform string occlusion_coordsys = "";
uniform string occlusion_subset = "";
uniform string occlusion_label = "";
uniform float occlusion_seed = -1.000;
uniform float occlusion_pointbased = 0.000;
uniform string occlusion_PtcFile = "";
uniform float occlusion_MaxSolidAngle = 0.100;
uniform float occlusion_clamp = 1.000;
float occlusion_result = 0.000;
color occlusion_env_color = color(0.000,0.000,0.000);
vector occlusion_bent_dir = vector(0.000,0.000,1.000);
color floatToColor_outColor = color(0.000,0.000,0.000);
string spec_ibi_category = "environment";
color spec_ibi_result = color(0.000,0.000,0.000);
color spec_ibi_sat_result = color(0.000,0.000,0.000);
string blinn_category = "";
color blinn_specColor = color(1.000,1.000,1.000);
float blinn_reflectivity = 1.000;
color blinn_result = color(0.000,0.000,0.000);
string diff_category = "";
float diff_atten = 1.000;
float diff_from = 0.000;
float diff_to = 1.000;
color diff_coloration = color(1.000,1.000,1.000);
color diff_result = color(0.000,0.000,0.000);
normal FaceforwardNormal_Nf = normal(0.000,0.000,0.000);
string diff_ibi_category = "environment";
color diff_ibi_result = color(0.000,0.000,0.000);
color diff_ibi_add_outColor = color(0.000,0.000,0.000);
color diff_ibi_clamp_min = color(0.000,0.000,0.000);
color diff_ibi_clamp_max = color(1.000,1.000,1.000);
color diff_ibi_clamp_result = color(0.000,0.000,0.000);
color diff_ibi_sat_result = color(0.000,0.000,0.000);
float ffwd_Abs = 1.000;
float ffwd_Clamp = 1.000;
float ffwd_Invert = 1.000;
float ffwd_result = 0.000;
color base_color_outColor = color(0.000,0.000,0.000);
color comp_diff_ibi_out = color(0.000,0.000,0.000);
color comp_diff_out = color(0.000,0.000,0.000);
color comp_spec_out = color(0.000,0.000,0.000);
color comp_spec_ibi_out = color(0.000,0.000,0.000);
color comp_occ_out = color(0.000,0.000,0.000);
color metal_ibi_Oi = color(1.000,1.000,1.000);
float metal_ibi_Premultiply = 1.000;
color metal_ibi_shadow = color(0.000,0.000,0.000);
color metal_ibi_reflect = color(0.000,0.000,0.000);
color metal_ibi_sss = color(0.000,0.000,0.000);
color metal_ibi_occ_C = color(0.000,0.000,0.000);
float metal_ibi_mask = 1.000;
color metal_ibi_mask_C = color(1.000,0.000,0.000);
color metal_ibi_extra_C = color(1.000,0.000,0.000);
float metal_ibi_extra_F = 1.000;

	float cosangle = normalize(-I).normalize(N);
	if( cosangle < 0)
		ffwd_result = -pow(-cosangle, ffwd_Attenuation);
	else
		ffwd_result = pow(cosangle, ffwd_Attenuation);
	if( ffwd_Abs != 0 )
		ffwd_result = abs(ffwd_result);
	if( ffwd_Clamp != 0 )
	 	ffwd_result = clamp(ffwd_result, 0, 1);
	if( ffwd_Invert != 0 )
		ffwd_result = 1 - ffwd_result;
  
base_color_outColor = mix((base_color_inColor1), (base_color_inColor2), (ffwd_result));

	FaceforwardNormal_Nf = faceforward( normalize(N), I );
	
	
	__L = vector ( FaceforwardNormal_Nf );
  __blur = diff_ibi_dBlur;
	
	  
	illuminance ( diff_ibi_category, P,  "lightcache", "refresh" ) 
  {
    diff_ibi_result += Cl;
  }     

  diff_ibi_result *= diff_ibi_Kd;
			
  
 diff_ibi_add_outColor = diff_ibi_result + diff_ibi_add_inColor2;

 diff_ibi_clamp_result = clamp((diff_ibi_add_outColor), (diff_ibi_clamp_min), (diff_ibi_clamp_max));

	float diff_ibi_sat_lum = .2125*comp( diff_ibi_clamp_result, 0) + .7154*comp(diff_ibi_clamp_result, 1) + .0721*comp(diff_ibi_clamp_result, 2);
	diff_ibi_sat_result = mix( color( diff_ibi_sat_lum ), diff_ibi_clamp_result, diff_ibi_sat_value );
	

	comp_diff_ibi_out = base_color_outColor * ( (1 - comp_diff_ibi_mult) + comp_diff_ibi_mult * diff_ibi_sat_result );
	
	
	
	color diff_diffColor = 0;
              
	illuminance ( diff_category, P, FaceforwardNormal_Nf, PI/2, "lightcache", "refresh" ) 
	{
		float nondiff = 0;
		lightsource( "__nondiffuse", nondiff );
		if (nondiff < 1)
			diff_diffColor += ( 1 - nondiff ) * Cl *( FaceforwardNormal_Nf.normalize(L) );
	}
	
	float diff_hueComp = comp( ctransform( "hsv" , diff_diffColor ) , 0 );
	float diff_satComp = comp( ctransform( "hsv" , diff_diffColor ), 1 );
	float diff_lumiComp = comp( ctransform( "hsv" , diff_diffColor ), 2 ); /*  get value component from HSV color space */
	color diff_hsvDiff = color "hsv" ( diff_hueComp, diff_satComp, ( diff_from + ( diff_to - diff_from ) * pow( diff_lumiComp, diff_atten ) ) );
  
	diff_result = diff_coloration * diff_Kd * diff_hsvDiff;
			
  

	comp_diff_out = comp_diff_ibi_out * ( (1 - comp_diff_mult) + comp_diff_mult * diff_result );
	
	
  
  vector blinn_R = reflect( normalize(I), normalize( FaceforwardNormal_Nf ) );
  vector blinn_V = normalize(-I);
  float blinn_VN = blinn_V.FaceforwardNormal_Nf;
  color blinn_C = 0, blinn_Cr = 0;
  float blinn_E = 0;
  
  if ( blinn_eccentricity != 1 )
    blinn_E = 1 / ( blinn_eccentricity * blinn_eccentricity - 1);
  else
    blinn_E = -1e5;
  
  illuminance( blinn_category, P, FaceforwardNormal_Nf, PI/2, "lightcache", "refresh" )
  {
    vector H, Ln;
    float nondiff, nonspec;
    float NH, NH2, NHSQ, Dd, Gg, VH, LN, Ff, tmp;
    
    if( 0 == lightsource("__nonspecular", nonspec) )
      nonspec = 0;
    if( nonspec < 1 )
    {
      Ln = normalize(L);
      H = normalize( Ln + blinn_V );
      NH = FaceforwardNormal_Nf.H;
      NHSQ = NH * NH;
      NH2 = NH * 2;
      Dd = ( blinn_E + 1 ) / ( NHSQ + blinn_E );
      Dd *= Dd;
      VH = blinn_V.H;
      LN = Ln.FaceforwardNormal_Nf;
      if( blinn_VN < LN )
      {
        if( blinn_VN * NH2 < VH )
          Gg = NH2 / VH;
        else
          Gg = 1 / blinn_VN;
      }
      else
      {
        if( LN * NH2 < VH )
          Gg = (LN * NH2) / (VH * blinn_VN);
        else
          Gg = 1 / blinn_VN;
      }
      /* poor man's Fresnel */
      tmp = pow((1 - VH), 3);
      Ff = tmp + (1 - tmp) * blinn_specularRollOff;
      blinn_C += Cl * Dd * Gg * Ff;
    
      /* now look for environment reflections.  
         These are indicated by lights which are specular AND nondiffuse 
      */
      if( 0 != lightsource( "__nondiffuse", nondiff ) )
      {
        blinn_Cr += ( 1 - nonspec ) * nondiff * Ff * Cl;
      }
    }
  }
     
 blinn_result = blinn_Ks * blinn_specColor * ( blinn_C + blinn_reflectivity * blinn_Cr );
  
  

	comp_spec_out = comp_diff_out  + comp_spec_mult * blinn_result;
	
	

  float spec_ibi_Kr = spec_ibi_KrMax;
	vector spec_ibi_R = vector (0);
	vector spec_ibi_V = normalize( I );  
  
  if ( spec_ibi_IOR > 0 )
	{
    vector T;
    float Kt;
    float f = max( spec_ibi_IOR, 1.0e-4 );
    fresnel( spec_ibi_V, FaceforwardNormal_Nf, ( I.FaceforwardNormal_Nf < 0 ) ? 1.0/f : spec_ibi_IOR , spec_ibi_Kr, Kt, spec_ibi_R, T );
    spec_ibi_Kr = mix( spec_ibi_KrMin, spec_ibi_KrMax, spec_ibi_Kr );
	}
	else
	{
    spec_ibi_R = reflect( spec_ibi_V, FaceforwardNormal_Nf );
	}
  
  __L = spec_ibi_R;
  __blur = spec_ibi_rBlur;
  /* P = P; dirty light cache */
  illuminance ( spec_ibi_category, P, "lightcache", "refresh" ) /* , "lightcache", "refresh" */
  {
    spec_ibi_result += Cl;
  }     

  spec_ibi_result *= spec_ibi_Kr;
			
  
	float spec_ibi_sat_lum = .2125*comp( spec_ibi_result, 0) + .7154*comp(spec_ibi_result, 1) + .0721*comp(spec_ibi_result, 2);
	spec_ibi_sat_result = mix( color( spec_ibi_sat_lum ), spec_ibi_result, spec_ibi_sat_value );
	

	comp_spec_ibi_out = comp_spec_out  + comp_spec_ibi_mult * spec_ibi_sat_result;
	
	
	ShadingNormal_NS = normalize(N);
	uniform float ShadingNormal_depth;
	
	rayinfo("depth", ShadingNormal_depth);
	if ( ShadingNormal_depth > 0 )
		ShadingNormal_NS = faceforward( ShadingNormal_NS, I, ShadingNormal_NS);
	else
	{
		uniform float sides = 2;
		attribute( "Sides", sides );
		if  (sides == 2 )
		  ShadingNormal_NS = faceforward( ShadingNormal_NS, I, ShadingNormal_NS );
	}	    
	
	
  
	/* extern point P; */
  /* extern normal N; */
  /* normal Nss = meShadingNormal( N ); */
  
  /* if ( occlusion_MaxDist == -1 )
	  occlusion_MaxDist = 1.0e38; */
	
	#ifdef AIR  
   color occlusion_occ_C = occlusion( P  
              ,ShadingNormal_NS 
              ,radians( occlusion_ConeAngle )
              ,bent_dir
              ,"samples",       occlusion_MaxSamples
              /* ,"blur", mapblur */
              ,"bias",          occlusion_Bias
              ,"label",         occlusion_label
              ,"subset",        occlusion_subset
              ,"maxdist",       occlusion_MaxDist
              ,"maxerror",      occlusion_MaxError 
              ,"maxpixeldist",  MaxPixelDist );
             occlusion_result = comp( occlusion_occ_C, 0 ); 
#else                           
   #ifdef PIXIE
   occlusion_result = occlusion( P  
              ,ShadingNormal_NS            
              ,occlusion_MaxSamples
              ,"irradiance",    occlusion_env_color /* The irradiance amount (output)  */
              /*,"minR",          MaxPixelDist  uniform float minR	 The closest distance between samples. */
              /*,"maxR",          MaxPixelDist uniform float maxR	The maximum distance between samples. */
              ,"bias",          occlusion_Bias
              ,"maxdist",       occlusion_MaxDist );
   #else
   occlusion_result = occlusion( P  
              ,ShadingNormal_NS            
              ,occlusion_MaxSamples
              ,"adaptive",      occlusion_Adaptive
              ,"minsamples",    occlusion_MinSamples
              ,"maxdist",       occlusion_MaxDist
  #ifdef DELIGHT             
              ,"axis",          occlusion_SkyAxis
  #endif              
              ,"coneangle",     radians( occlusion_ConeAngle )
              ,"samplebase",    occlusion_SampleBase
              ,"bias",          occlusion_Bias
              ,"hitmode",       occlusion_HitMode
              ,"hitsides",      occlusion_HitSides
              ,"maxvariation",  occlusion_MaxVar
  #ifndef DELIGHT              
              ,"maxerror",      occlusion_MaxError
              ,"maxpixeldist",  occlusion_MaxPixelDist
              ,"seed",          occlusion_seed
              ,"brightnesswarp",  occlusion_BrtWarp
  #endif               
              ,"distribution",  occlusion_Distribution
              ,"falloffmode",   occlusion_FalloffMode
              ,"falloff",       occlusion_FalloffValue
              
              ,"environmentmap",    occlusion_EnvMap
              ,"environmentspace",  occlusion_EnvSpace
              
              ,"coordsystem",   occlusion_coordsys
              ,"subset",        occlusion_subset
              ,"label",         occlusion_label

              ,"pointbased",    occlusion_pointbased
              ,"filename",      occlusion_PtcFile
              ,"maxsolidangle", occlusion_MaxSolidAngle
              ,"clamp",         occlusion_clamp
              
              ,"environmentcolor",  occlusion_env_color
              ,"environmentdir",    occlusion_bent_dir );

  #endif /* PIXIE */             
#endif  /* AIR */           
              
  if ( occlusion_Invert == 1 )              
    occlusion_result = 1 - occlusion_result;            
  
	  floatToColor_outColor = color(occlusion_result, occlusion_result, occlusion_result);
	  

	comp_occ_out = comp_spec_ibi_out * ( (1 - comp_occ_mult) + comp_occ_mult * ( 1 - floatToColor_outColor ) );
	
		
	  normal psTrace_Nf;
 		normal psTrace_Nc;
	
 		psTrace_Nf = faceforward(normalize(N), I);
    psTrace_Nc = transform("camera", (psTrace_Nf + point "camera" (0,0,0)));
    psTrace_Nc = normalize(psTrace_Nc);
		    
    setcomp(psTrace_out, 0, clamp((0.5 - xcomp(psTrace_Nc) / 2), 0, 1));
    setcomp(psTrace_out, 1, clamp((0.5 + ycomp(psTrace_Nc) / 2), 0, 1));
    setcomp(psTrace_out, 2, clamp(abs(zcomp(psTrace_Nc)), 0, 1));	
  
	Ci = comp_occ_out * metal_ibi_Oi; 
	Oi = metal_ibi_Oi;
	__color = base_color_outColor * metal_ibi_Oi;
	__diff = diff_result * metal_ibi_Oi;
	__spec = blinn_result * metal_ibi_Oi;
	__diff_ibi = diff_ibi_sat_result * metal_ibi_Oi;
	__spec_ibi = spec_ibi_sat_result * metal_ibi_Oi;
	__shadow = metal_ibi_shadow * metal_ibi_Oi;
	__reflect = metal_ibi_reflect * metal_ibi_Oi;
	__sss = metal_ibi_sss * metal_ibi_Oi;
	
	__pstrace = psTrace_out * metal_ibi_Oi;
	
	__occ = comp ( occlusion_result * metal_ibi_Oi, 0 );
	__occ_C = metal_ibi_occ_C * metal_ibi_Oi;
	
	__mask = comp ( metal_ibi_mask * metal_ibi_Oi, 0 );
	__mask_C = metal_ibi_mask_C * metal_ibi_Oi;
	
	color metal_ibi_dummy_C = metal_ibi_extra_C * metal_ibi_Oi;
	float metal_ibi_dummy_F = comp ( metal_ibi_extra_F * metal_ibi_Oi, 0 ); 
	
	
}
